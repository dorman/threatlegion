<div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8">
  <div class="mb-6 flex justify-between items-center">
    <div>
      <h1 class="text-3xl font-bold text-gray-900"><%= @workflow.name %></h1>
      <p class="mt-2 text-sm text-gray-600"><%= @workflow.description %></p>
    </div>
    <div class="flex space-x-3">
      <%= link_to "Back to Workflows", admin_workflows_path, class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50" %>
      <%= link_to "View Results", results_admin_workflow_path(@workflow), class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700" %>
      <%= button_to "Execute Workflow", execute_admin_workflow_path(@workflow), method: :post, class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700" %>
    </div>
  </div>

  <!-- Workflow Builder with Sidebar -->
  <div class="bg-slate-900 shadow-2xl rounded-lg mb-6 overflow-hidden border border-slate-700">
    <div class="flex" style="height: 800px;">
      <!-- Services Sidebar - Modern Dark Theme -->
      <div class="w-64 flex-shrink-0 overflow-y-auto" style="background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);">
        <div class="p-4 border-b border-cyan-500/20 sticky top-0 z-10" style="background: linear-gradient(180deg, #0f172a 0%, rgba(15, 23, 42, 0.95) 100%); backdrop-filter: blur(8px);">
          <h3 class="text-sm font-semibold text-white uppercase tracking-wide flex items-center gap-2">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
            </svg>
            Available Services
          </h3>
          <p class="mt-1 text-xs text-white">Click + to add to canvas</p>
        </div>
        <div class="p-3 space-y-2" id="services-sidebar">
          <% @service_info.each do |service_key, service_data| %>
            <div
              class="service-item group p-3 rounded-lg cursor-default transition-all duration-200"
              style="background: linear-gradient(135deg, #1e293b 0%, #334155 100%); border: 1px solid #475569;"
              data-service-key="<%= service_key %>"
              data-service-name="<%= service_data[:name] %>">
              <div class="flex items-center gap-3">
                <div class="flex-shrink-0">
                  <div class="w-9 h-9 rounded-lg flex items-center justify-center" style="background: linear-gradient(135deg, rgba(34, 211, 238, 0.15) 0%, rgba(168, 85, 247, 0.15) 100%); border: 1px solid rgba(34, 211, 238, 0.2); box-shadow: 0 0 8px rgba(34, 211, 238, 0.2);">
                    <svg class="w-5 h-5 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                    </svg>
                  </div>
                </div>
                <div class="flex-1 min-w-0">
                  <p class="text-sm font-medium text-white truncate group-hover:text-cyan-300 transition-colors" style="text-shadow: 0 0 8px rgba(34, 211, 238, 0.1);"><%= service_data[:name] %></p>
                  <p class="text-xs text-slate-500 truncate"><%= service_data[:description] %></p>
                </div>
                <button
                  type="button"
                  class="add-node-btn flex-shrink-0 w-8 h-8 rounded-lg flex items-center justify-center transition-all duration-200 hover:scale-110"
                  style="background: linear-gradient(135deg, #22d3ee 0%, #06b6d4 100%); color: #0f172a;"
                  data-service-key="<%= service_key %>"
                  data-service-name="<%= service_data[:name] %>"
                  title="Add to canvas">
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" stroke-width="2.5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" />
                  </svg>
                </button>
              </div>
            </div>
          <% end %>
        </div>
      </div>

      <!-- React Flow Canvas -->
      <div class="flex-1 relative" id="react-flow-container" style="min-width: 0; width: 100%; height: 100%; overflow: hidden;">
        <div id="workflow-builder"
             data-workflow-id="<%= @workflow.id %>"
             data-workflow-data="<%= @workflow_data.to_json %>"
             data-services="<%= @service_info.to_json %>"
             data-update-url="<%= admin_workflow_path(@workflow) %>"
             data-node-data-url="<%= node_data_admin_workflow_path(@workflow) %>"
             data-update-node-config-url="<%= update_node_config_admin_workflow_path(@workflow) %>"
             style="width: 100%; height: 100%; position: relative;">
          <div id="react-flow-root" style="width: 100%; height: 100%; background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%); position: relative;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Recent Executions -->
  <div class="bg-white shadow rounded-lg">
    <div class="px-4 py-5 sm:px-6">
      <h3 class="text-lg leading-6 font-medium text-gray-900">Recent Executions</h3>
    </div>
    <div class="border-t border-gray-200">
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Started</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Records</th>
            <th scope="col" class="relative px-6 py-3"><span class="sr-only">View</span></th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
          <% @executions.each do |execution| %>
            <tr class="hover:bg-gray-50">
              <td class="px-6 py-4 whitespace-nowrap">
                <% case execution.status %>
                <% when 'completed' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">Completed</span>
                <% when 'failed' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-red-100 text-red-800">Failed</span>
                <% when 'running' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-blue-100 text-blue-800">Running</span>
                <% else %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-gray-100 text-gray-800">Pending</span>
                <% end %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.started_at ? time_ago_in_words(execution.started_at) + " ago" : "N/A" %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.duration ? "#{execution.duration.round(2)}s" : "N/A" %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.records_processed || 0 %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                <%= link_to "View", results_admin_workflow_path(@workflow, execution_id: execution.id), class: "text-red-600 hover:text-red-900" %>
              </td>
            </tr>
          <% end %>
        </tbody>
      </table>
    </div>
  </div>
</div>

<!-- Node Data Modal -->
<div id="node-data-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
  <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
    <div class="mt-3">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-medium text-gray-900" id="node-data-title">Node Data Output</h3>
        <button id="close-node-modal-btn" type="button" class="text-gray-400 hover:text-gray-600">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      <div id="node-data-content" class="max-h-96 overflow-y-auto">
        <div class="text-center py-8 text-gray-500">
          <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
          <p class="mt-2">Loading data...</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Node Configuration Modal -->
<div id="node-config-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
  <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-xl shadow-lg rounded-md bg-white">
    <div class="mt-3">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-medium text-gray-900" id="node-config-title">Configure Node</h3>
        <button id="close-config-modal-btn" type="button" class="text-gray-400 hover:text-gray-600">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      <form id="node-config-form" class="space-y-4">
        <input type="hidden" id="config-node-id" name="node_id" />
        <input type="hidden" id="config-service-name" name="service_name" />

        <!-- Node Label -->
        <div>
          <label for="config-node-label" class="block text-sm font-medium text-gray-700">Node Label</label>
          <input type="text" id="config-node-label" name="label"
                 class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm"
                 placeholder="Enter a custom label for this node" />
        </div>

        <!-- Method Selection -->
        <div>
          <label for="config-method" class="block text-sm font-medium text-gray-700">Method</label>
          <select id="config-method" name="method"
                  class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm">
            <option value="">Select a method...</option>
          </select>
          <p id="method-description" class="mt-1 text-xs text-gray-500"></p>
        </div>

        <!-- Dynamic Input Fields Container -->
        <div id="config-inputs-container" class="space-y-4">
          <!-- Dynamic fields will be inserted here -->
        </div>

        <!-- API Key Section (for services that need it) -->
        <div id="api-key-section" class="hidden border-t pt-4 mt-4">
          <h4 class="text-sm font-medium text-gray-700 mb-2">API Configuration</h4>
          <div id="api-key-fields" class="space-y-3">
            <!-- API key fields will be inserted here -->
          </div>
        </div>

        <!-- Form Actions -->
        <div class="flex justify-end space-x-3 pt-4 border-t">
          <button type="button" id="cancel-config-btn"
                  class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50">
            Cancel
          </button>
          <button type="submit"
                  class="px-4 py-2 text-sm font-medium text-white bg-red-600 border border-transparent rounded-md hover:bg-red-700">
            Save Configuration
          </button>
        </div>
      </form>
    </div>
  </div>
</div>

<%= stylesheet_link_tag "https://unpkg.com/reactflow@11/dist/style.css" %>

<style>
  /* Dark theme overrides for React Flow */
  .react-flow__controls {
    background: #1e293b !important;
    border: 1px solid #475569 !important;
    border-radius: 8px !important;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3) !important;
  }

  .react-flow__controls-button {
    background: #1e293b !important;
    border-bottom: 1px solid #475569 !important;
    color: #94a3b8 !important;
    fill: #94a3b8 !important;
  }

  .react-flow__controls-button:hover {
    background: #334155 !important;
    color: #22d3ee !important;
    fill: #22d3ee !important;
  }

  .react-flow__controls-button svg {
    fill: currentColor !important;
  }

  .react-flow__minimap {
    background: #0f172a !important;
    border: 1px solid #475569 !important;
    border-radius: 8px !important;
  }

  .react-flow__edge-path {
    stroke: #22d3ee !important;
    filter: drop-shadow(0 0 3px rgba(34, 211, 238, 0.5));
  }

  .react-flow__edge.animated path {
    stroke-dasharray: 5 !important;
    animation: dashdraw 0.5s linear infinite !important;
  }

  @keyframes dashdraw {
    from { stroke-dashoffset: 10; }
    to { stroke-dashoffset: 0; }
  }

  .react-flow__handle {
    transition: all 0.2s ease !important;
  }

  .react-flow__handle:hover {
    transform: scale(1.3) !important;
    box-shadow: 0 0 15px currentColor !important;
  }

  /* Selection box */
  .react-flow__selection {
    background: rgba(34, 211, 238, 0.1) !important;
    border: 1px dashed #22d3ee !important;
  }

  /* Attribution hidden */
  .react-flow__attribution {
    display: none !important;
  }

  /* Add node button hover effect */
  .add-node-btn {
    box-shadow: 0 0 10px rgba(34, 211, 238, 0.3);
  }
  .add-node-btn:hover {
    box-shadow: 0 0 20px rgba(34, 211, 238, 0.5);
  }

  /* Service item hover effect */
  .service-item {
    box-shadow: 0 0 12px rgba(34, 211, 238, 0.05), 0 2px 8px rgba(0, 0, 0, 0.2);
  }
  .service-item:hover {
    box-shadow: 0 0 20px rgba(34, 211, 238, 0.15), 0 4px 16px rgba(0, 0, 0, 0.3);
    border-color: rgba(34, 211, 238, 0.4) !important;
  }
</style>
<%= javascript_include_tag "https://unpkg.com/react@18/umd/react.development.js" %>
<%= javascript_include_tag "https://unpkg.com/react-dom@18/umd/react-dom.development.js" %>
<%= javascript_include_tag "https://unpkg.com/reactflow@11/dist/umd/index.js" %>

<script>
  (function() {
    // Prevent multiple initializations of event listeners
    if (window._workflowBuilderListenersAttached) {
      // Just re-initialize the builder if listeners are already attached
      setTimeout(function() {
        if (typeof window._initWorkflowBuilder === 'function') {
          window._initWorkflowBuilder();
        }
      }, 100);
      return;
    }
    window._workflowBuilderListenersAttached = true;

    // Track if we've already initialized to avoid double-init
    let reactFlowRoot = null;
    let initialized = false;

    function initWorkflowBuilder() {
      const builderEl = document.getElementById('workflow-builder');
      if (!builderEl) return;

      // Check if already initialized with same workflow
      const workflowId = builderEl.dataset.workflowId;
      if (initialized && window._currentWorkflowId === workflowId) {
        console.log('Workflow builder already initialized for this workflow');
        return;
      }

      console.log('Initializing workflow builder for workflow:', workflowId);
      initialized = true;
      window._currentWorkflowId = workflowId;

      const workflowData = JSON.parse(builderEl.dataset.workflowData || '{"nodes":[],"edges":[]}');
      const services = JSON.parse(builderEl.dataset.services || '{}');
      const updateUrl = builderEl.dataset.updateUrl;
      const nodeDataUrlTemplate = builderEl.dataset.nodeDataUrl;
      const updateNodeConfigUrl = builderEl.dataset.updateNodeConfigUrl;

      const { React, ReactDOM } = window;
      const ReactFlow = window.ReactFlow;

      if (!React || !ReactDOM || !ReactFlow) {
        console.error('React Flow not loaded');
        return;
      }

    const { useCallback, useState, useRef, useEffect, useMemo } = React;

    // React Flow v11 UMD build - get components
    const FlowLib = window.ReactFlow;
    console.log('ReactFlow keys:', Object.keys(FlowLib || {}));

    const ReactFlowProvider = FlowLib.ReactFlowProvider;
    const useReactFlow = FlowLib.useReactFlow;
    const applyNodeChanges = FlowLib.applyNodeChanges;
    const applyEdgeChanges = FlowLib.applyEdgeChanges;
    const addEdge = FlowLib.addEdge;
    const Background = FlowLib.Background;
    const Controls = FlowLib.Controls;
    const MiniMap = FlowLib.MiniMap;
    const Handle = FlowLib.Handle;
    const Position = FlowLib.Position || { Left: 'left', Right: 'right', Top: 'top', Bottom: 'bottom' };
    const ReactFlowComponent = FlowLib.default || FlowLib.ReactFlow;

    console.log('React Flow components:', {
      ReactFlowProvider: !!ReactFlowProvider,
      applyNodeChanges: !!applyNodeChanges,
      applyEdgeChanges: !!applyEdgeChanges,
      ReactFlowComponent: !!ReactFlowComponent
    });

    // Global state for node config modal
    window.nodeConfigState = {};

    // Modern Dark themed custom node - Compact version
    function ServiceNode({ data, id }) {
      const configuredMethod = data.config?.method;
      const [isHovered, setIsHovered] = useState(false);

      return React.createElement('div', {
        onMouseEnter: () => setIsHovered(true),
        onMouseLeave: () => setIsHovered(false),
        style: {
          padding: '10px 12px',
          borderRadius: '8px',
          background: 'linear-gradient(135deg, #1e293b 0%, #334155 100%)',
          border: '1px solid #475569',
          minWidth: '140px',
          maxWidth: '160px',
          boxShadow: isHovered
            ? '0 0 20px rgba(34, 211, 238, 0.25), 0 0 40px rgba(168, 85, 247, 0.1), 0 4px 20px rgba(0, 0, 0, 0.4)'
            : '0 0 12px rgba(34, 211, 238, 0.1), 0 0 24px rgba(168, 85, 247, 0.05), 0 2px 8px rgba(0, 0, 0, 0.3)',
          transition: 'all 0.2s ease',
          fontSize: '12px'
        }
      }, [
        // Handles for connections - compact
        Handle && React.createElement(Handle, {
          key: 'target',
          type: 'target',
          position: Position.Left,
          style: {
            background: '#3b82f6',
            width: '8px',
            height: '8px',
            border: '1.5px solid #1e293b',
            boxShadow: '0 0 6px rgba(59, 130, 246, 0.5)'
          }
        }),
        Handle && React.createElement(Handle, {
          key: 'source',
          type: 'source',
          position: Position.Right,
          style: {
            background: '#22d3ee',
            width: '8px',
            height: '8px',
            border: '1.5px solid #1e293b',
            boxShadow: '0 0 6px rgba(34, 211, 238, 0.5)'
          }
        }),
        // Content - compact
        React.createElement('div', { key: 'content' }, [
          // Header with label and config button
          React.createElement('div', {
            key: 'header',
            style: {
              display: 'flex',
              justifyContent: 'space-between',
              alignItems: 'center',
              marginBottom: '4px',
              gap: '4px'
            }
          }, [
            React.createElement('span', {
              key: 'label',
              style: {
                fontWeight: '600',
                fontSize: '11px',
                color: '#f8fafc',
                textShadow: '0 0 8px rgba(34, 211, 238, 0.2)',
                whiteSpace: 'nowrap',
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                flex: 1
              }
            }, data.label || 'Node'),
            React.createElement('span', {
              key: 'config',
              className: 'nodrag',
              onClick: (e) => {
                e.stopPropagation();
                console.log('Config clicked:', id);
                const event = new CustomEvent('openNodeConfig', { detail: { nodeId: id, nodeData: data } });
                document.dispatchEvent(event);
              },
              style: {
                cursor: 'pointer',
                padding: '2px 4px',
                borderRadius: '4px',
                background: 'rgba(71, 85, 105, 0.4)',
                transition: 'all 0.15s ease',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                flexShrink: 0
              }
            }, React.createElement('svg', {
              width: '12',
              height: '12',
              viewBox: '0 0 24 24',
              fill: 'none',
              stroke: '#94a3b8',
              strokeWidth: '2',
              strokeLinecap: 'round',
              strokeLinejoin: 'round'
            }, [
              React.createElement('circle', { key: 'c1', cx: '12', cy: '12', r: '3' }),
              React.createElement('path', { key: 'p1', d: 'M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z' })
            ]))
          ]),
          // Service name badge - compact
          React.createElement('div', {
            key: 'service',
            style: {
              fontSize: '9px',
              color: '#22d3ee',
              marginBottom: '3px',
              padding: '1px 5px',
              background: 'rgba(34, 211, 238, 0.1)',
              borderRadius: '3px',
              display: 'inline-block',
              fontFamily: 'monospace'
            }
          }, data.service_name || ''),
          // Method display - compact
          React.createElement('div', {
            key: 'method',
            style: {
              fontSize: '9px',
              color: configuredMethod ? '#a855f7' : '#64748b',
              marginTop: '2px',
              fontFamily: 'monospace',
              whiteSpace: 'nowrap',
              overflow: 'hidden',
              textOverflow: 'ellipsis'
            }
          }, configuredMethod ? `→ ${configuredMethod}` : '⚡ Configure'),
          // View Output button
          React.createElement('div', {
            key: 'view',
            className: 'nodrag',
            onClick: (e) => {
              e.stopPropagation();
              console.log('View clicked:', id);
              const modal = document.getElementById('node-data-modal');
              const contentDiv = document.getElementById('node-data-content');
              if (modal) {
                document.getElementById('node-data-title').textContent = data.label + ' - Output';
                // Reset to loading state
                contentDiv.innerHTML = `
                  <div class="text-center py-8 text-gray-500">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-cyan-400 mx-auto"></div>
                    <p class="mt-2">Loading data...</p>
                  </div>
                `;
                modal.classList.remove('hidden');

                // Fetch node data from backend
                const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
                fetch(`${nodeDataUrlTemplate}?node_id=${encodeURIComponent(id)}`, {
                  method: 'GET',
                  headers: {
                    'Accept': 'application/json',
                    'X-CSRF-Token': csrfToken
                  }
                })
                .then(response => response.json())
                .then(result => {
                  if (result.error) {
                    contentDiv.innerHTML = `
                      <div class="text-center py-8 text-red-500">
                        <p>Error: ${result.error}</p>
                      </div>
                    `;
                    return;
                  }

                  // Build the display content
                  let html = '';

                  // Show node config summary
                  if (result.node) {
                    html += `<div class="mb-4 p-3 bg-gray-50 rounded-lg">
                      <h4 class="font-medium text-gray-700 mb-2">Node Configuration</h4>
                      <p class="text-sm text-gray-600"><strong>Service:</strong> ${result.node.service_name || 'N/A'}</p>
                      <p class="text-sm text-gray-600"><strong>Method:</strong> ${result.node.config?.method || 'Not configured'}</p>
                    </div>`;
                  }

                  // Show message if no data
                  if (result.message) {
                    html += `<div class="text-center py-4 text-gray-500">
                      <p>${result.message}</p>
                    </div>`;
                  }

                  // Show execution status
                  if (result.execution_status) {
                    const statusColors = {
                      'completed': 'bg-green-100 text-green-800',
                      'failed': 'bg-red-100 text-red-800',
                      'running': 'bg-blue-100 text-blue-800',
                      'pending': 'bg-gray-100 text-gray-800'
                    };
                    html += `<div class="mb-4">
                      <span class="px-2 py-1 text-xs font-semibold rounded-full ${statusColors[result.execution_status] || 'bg-gray-100 text-gray-800'}">
                        Execution: ${result.execution_status}
                      </span>
                    </div>`;
                  }

                  // Show data results
                  if (result.data && Array.isArray(result.data) && result.data.length > 0) {
                    html += `<div class="mb-2 text-sm text-gray-600">
                      <strong>Results:</strong> ${result.data.length} records
                    </div>`;
                    html += `<div class="overflow-x-auto">
                      <pre class="bg-gray-900 text-green-400 p-4 rounded-lg text-xs overflow-auto max-h-64">${JSON.stringify(result.data.slice(0, 50), null, 2)}</pre>
                    </div>`;
                    if (result.data.length > 50) {
                      html += `<p class="mt-2 text-xs text-gray-500">Showing first 50 of ${result.data.length} records</p>`;
                    }
                  } else if (result.data && typeof result.data === 'object' && Object.keys(result.data).length > 0) {
                    html += `<div class="overflow-x-auto">
                      <pre class="bg-gray-900 text-green-400 p-4 rounded-lg text-xs overflow-auto max-h-64">${JSON.stringify(result.data, null, 2)}</pre>
                    </div>`;
                  } else if (!result.message) {
                    html += `<div class="text-center py-4 text-gray-500">
                      <p>No output data available. Execute the workflow to see results.</p>
                    </div>`;
                  }

                  contentDiv.innerHTML = html;
                })
                .catch(error => {
                  console.error('Error fetching node data:', error);
                  contentDiv.innerHTML = `
                    <div class="text-center py-8 text-red-500">
                      <p>Error loading data: ${error.message}</p>
                    </div>
                  `;
                });
              }
            },
            style: {
              marginTop: '6px',
              padding: '4px 8px',
              background: 'linear-gradient(135deg, rgba(34, 211, 238, 0.08) 0%, rgba(168, 85, 247, 0.08) 100%)',
              border: '1px solid rgba(34, 211, 238, 0.25)',
              borderRadius: '4px',
              fontSize: '9px',
              textAlign: 'center',
              cursor: 'pointer',
              color: '#94a3b8',
              fontWeight: '500',
              transition: 'all 0.15s ease',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              gap: '4px'
            }
          }, [
            React.createElement('svg', {
              key: 'icon',
              width: '10',
              height: '10',
              viewBox: '0 0 24 24',
              fill: 'none',
              stroke: '#22d3ee',
              strokeWidth: '2',
              strokeLinecap: 'round',
              strokeLinejoin: 'round'
            }, [
              React.createElement('path', { key: 'p1', d: 'M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z' }),
              React.createElement('circle', { key: 'c1', cx: '12', cy: '12', r: '3' })
            ]),
            'Output'
          ])
        ])
      ]);
    }

    // Node types - must be defined outside component and be stable
    const nodeTypes = { service: ServiceNode };

    // Main workflow builder component - using controlled mode with applyNodeChanges
    const WorkflowBuilder = () => {
      // Use regular useState - we'll manually apply changes
      const [nodes, setNodes] = useState(workflowData.nodes || []);
      const [edges, setEdges] = useState(workflowData.edges || []);

      const reactFlowWrapper = useRef(null);

      // Track latest state in refs for async operations
      const nodesRef = useRef(nodes);
      const edgesRef = useRef(edges);
      useEffect(() => {
        nodesRef.current = nodes;
        edgesRef.current = edges;
      }, [nodes, edges]);

      console.log('WorkflowBuilder render - nodes:', nodes.length, 'edges:', edges.length);

      // Handle node changes (including drag)
      const onNodesChange = useCallback((changes) => {
        // Log all changes with full details for debugging
        changes.forEach(c => {
          console.log('Node change:', c.type, c.id, c.type === 'position' ? c.position : '');
        });

        if (applyNodeChanges) {
          setNodes((nds) => {
            const result = applyNodeChanges(changes, nds);
            return result;
          });
        } else {
          console.warn('applyNodeChanges not available, using fallback');
          setNodes((nds) => {
            let updated = [...nds];
            changes.forEach(change => {
              if (change.type === 'position' && change.position) {
                const idx = updated.findIndex(n => n.id === change.id);
                if (idx !== -1) {
                  updated[idx] = { ...updated[idx], position: change.position };
                }
              }
            });
            return updated;
          });
        }
      }, []);

      // Handle edge changes
      const onEdgesChange = useCallback((changes) => {
        if (applyEdgeChanges) {
          setEdges((eds) => applyEdgeChanges(changes, eds));
        }
      }, []);

      // Handle new connections
      const onConnect = useCallback((connection) => {
        console.log('onConnect:', connection);
        if (addEdge) {
          setEdges((eds) => addEdge(connection, eds));
        } else {
          const newEdge = { ...connection, id: `edge-${Date.now()}` };
          setEdges((eds) => [...eds, newEdge]);
        }
      }, []);

      // Save workflow
      const saveWorkflow = useCallback(() => {
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
        if (!csrfToken) return;

        fetch(updateUrl, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken,
            'Accept': 'application/json'
          },
          body: JSON.stringify({
            workflow: {
              workflow_data: {
                nodes: nodesRef.current,
                edges: edgesRef.current
              }
            }
          })
        })
        .then(r => r.json())
        .then(() => console.log('Saved'))
        .catch(e => console.error('Save error:', e));
      }, []);

      // Track when dragging starts
      const onNodeDragStart = useCallback((event, node) => {
        console.log('>>> DRAG STARTED:', node.id, node.position);
      }, []);

      // Track during drag
      const onNodeDrag = useCallback((event, node) => {
        console.log('>>> DRAGGING:', node.id, node.position);
      }, []);

      // Save on drag end
      const onNodeDragStop = useCallback((event, node) => {
        console.log('>>> DRAG STOPPED:', node.id, node.position);
        setTimeout(saveWorkflow, 100);
      }, [saveWorkflow]);

      // Add new node function
      const addNode = useCallback((serviceKey, serviceName) => {
        console.log('Adding node:', serviceKey);

        const currentNodes = nodesRef.current;
        let position = { x: 100, y: 100 };
        if (currentNodes.length > 0) {
          const maxX = Math.max(...currentNodes.map(n => n.position?.x || 0));
          position = { x: maxX + 280, y: 100 };
        }

        const serviceInfo = services[serviceKey];
        const newNode = {
          id: `node-${Date.now()}`,
          type: 'service',
          position,
          data: {
            label: serviceInfo?.name || serviceName,
            service_name: serviceKey,
            config: {}
          }
        };

        setNodes(nds => [...nds, newNode]);
        setTimeout(saveWorkflow, 200);
      }, [saveWorkflow]);

      // Expose to window
      useEffect(() => {
        window.addWorkflowNode = addNode;
        window.workflowSetNodes = setNodes;
        return () => {
          delete window.addWorkflowNode;
          delete window.workflowSetNodes;
        };
      }, [addNode]);

      // Memoize node types to prevent re-renders
      const memoizedNodeTypes = useMemo(() => nodeTypes, []);

      if (!ReactFlowComponent) {
        return React.createElement('div', { style: { padding: 20, color: 'red' } },
          'Error: React Flow not loaded'
        );
      }

      return React.createElement('div', {
        ref: reactFlowWrapper,
        style: { width: '100%', height: '100%', position: 'absolute', top: 0, left: 0 }
      },
        React.createElement(ReactFlowComponent, {
          nodes: nodes,
          edges: edges,
          onNodesChange: onNodesChange,
          onEdgesChange: onEdgesChange,
          onConnect: onConnect,
          onNodeDragStart: onNodeDragStart,
          onNodeDrag: onNodeDrag,
          onNodeDragStop: onNodeDragStop,
          nodeTypes: memoizedNodeTypes,
          fitView: true,
          fitViewOptions: { padding: 0.3 },
          defaultEdgeOptions: {
            type: 'smoothstep',
            style: { stroke: '#22d3ee', strokeWidth: 2 },
            animated: true
          },
          minZoom: 0.1,
          maxZoom: 2,
          proOptions: { hideAttribution: true }
        }, [
          Background && React.createElement(Background, {
            key: 'bg',
            variant: 'dots',
            gap: 24,
            size: 1,
            color: '#334155'
          }),
          Controls && React.createElement(Controls, {
            key: 'ctrl',
            style: {
              background: '#1e293b',
              border: '1px solid #475569',
              borderRadius: '8px'
            }
          }),
          MiniMap && React.createElement(MiniMap, {
            key: 'mm',
            nodeColor: '#22d3ee',
            maskColor: 'rgba(15, 23, 42, 0.8)',
            style: {
              background: '#0f172a',
              border: '1px solid #475569',
              borderRadius: '8px'
            }
          })
        ])
      );
    };

    // Setup modal close handlers
    function setupModalHandlers() {
      const modal = document.getElementById('node-data-modal');
      const closeBtn = document.getElementById('close-node-modal-btn');

      if (closeBtn) {
        closeBtn.onclick = () => {
          if (modal) modal.classList.add('hidden');
        };
      }

      if (modal) {
        modal.onclick = (e) => {
          if (e.target === modal) {
            modal.classList.add('hidden');
          }
        };
      }

      // Config modal handlers
      const configModal = document.getElementById('node-config-modal');
      const closeConfigBtn = document.getElementById('close-config-modal-btn');
      const cancelConfigBtn = document.getElementById('cancel-config-btn');

      if (closeConfigBtn) {
        closeConfigBtn.onclick = () => {
          if (configModal) configModal.classList.add('hidden');
        };
      }

      if (cancelConfigBtn) {
        cancelConfigBtn.onclick = () => {
          if (configModal) configModal.classList.add('hidden');
        };
      }

      if (configModal) {
        configModal.onclick = (e) => {
          if (e.target === configModal) {
            configModal.classList.add('hidden');
          }
        };
      }
    }

    setupModalHandlers();

    // Re-setup after Turbo navigation
    document.addEventListener('turbo:load', setupModalHandlers);
    document.addEventListener('turbo:render', setupModalHandlers);

    // Node configuration modal functions
    let currentConfigNodeId = null;
    let currentConfigNodeData = null;

    // Listen for custom event from React component
    document.addEventListener('openNodeConfig', function(e) {
      console.log('openNodeConfig event received:', e.detail);
      if (e.detail && e.detail.nodeId) {
        window.openNodeConfigModal(e.detail.nodeId, e.detail.nodeData);
      }
    });

    // Open the node configuration modal
    window.openNodeConfigModal = function(nodeId, nodeData) {
      console.log('openNodeConfigModal called with:', nodeId, nodeData);
      currentConfigNodeId = nodeId;
      currentConfigNodeData = nodeData;

      const modal = document.getElementById('node-config-modal');
      const title = document.getElementById('node-config-title');
      const nodeIdField = document.getElementById('config-node-id');
      const serviceNameField = document.getElementById('config-service-name');
      const labelField = document.getElementById('config-node-label');
      const methodSelect = document.getElementById('config-method');
      const methodDescription = document.getElementById('method-description');
      const inputsContainer = document.getElementById('config-inputs-container');
      const apiKeySection = document.getElementById('api-key-section');
      const apiKeyFields = document.getElementById('api-key-fields');

      if (!modal) {
        console.error('Config modal element not found!');
        return;
      }
      console.log('Modal element found, proceeding...');

      // Set title and hidden fields
      title.textContent = `Configure: ${nodeData.label || nodeData.service_name || 'Node'}`;
      nodeIdField.value = nodeId;
      serviceNameField.value = nodeData.service_name || '';
      labelField.value = nodeData.label || '';

      // Get service info for this node
      const serviceName = nodeData.service_name;
      const serviceInfo = services[serviceName];

      // Clear and populate method dropdown
      methodSelect.innerHTML = '<option value="">Select a method...</option>';
      methodDescription.textContent = '';
      inputsContainer.innerHTML = '';

      if (serviceInfo && serviceInfo.methods) {
        Object.entries(serviceInfo.methods).forEach(([methodKey, methodInfo]) => {
          const option = document.createElement('option');
          option.value = methodKey;
          option.textContent = methodInfo.name || methodKey;
          // Select current method if configured
          if (nodeData.config && nodeData.config.method === methodKey) {
            option.selected = true;
          }
          methodSelect.appendChild(option);
        });

        // If a method is selected, show its description and inputs
        if (nodeData.config && nodeData.config.method) {
          const selectedMethod = serviceInfo.methods[nodeData.config.method];
          if (selectedMethod) {
            methodDescription.textContent = selectedMethod.description || '';
            renderInputFields(selectedMethod.inputs || {}, nodeData.config || {});
          }
        }
      }

      // Handle method selection change
      methodSelect.onchange = function() {
        const selectedMethodKey = this.value;
        inputsContainer.innerHTML = '';
        methodDescription.textContent = '';

        if (selectedMethodKey && serviceInfo && serviceInfo.methods && serviceInfo.methods[selectedMethodKey]) {
          const methodInfo = serviceInfo.methods[selectedMethodKey];
          methodDescription.textContent = methodInfo.description || '';
          renderInputFields(methodInfo.inputs || {}, nodeData.config || {});
        }
      };

      // Handle API key section for services that need it
      apiKeySection.classList.add('hidden');
      apiKeyFields.innerHTML = '';

      if (serviceName === 'abuse_ch' || serviceName === 'abuseipdb') {
        apiKeySection.classList.remove('hidden');
        const apiKeyName = serviceName === 'abuse_ch' ? 'abuse_ch_api_key' : 'abuseipdb_api_key';
        const apiKeyLabel = serviceName === 'abuse_ch' ? 'abuse.ch API Key' : 'AbuseIPDB API Key';

        apiKeyFields.innerHTML = `
          <div>
            <label for="config-api-key" class="block text-sm font-medium text-gray-700">${apiKeyLabel}</label>
            <input type="password" id="config-api-key" name="api_key"
                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm"
                   placeholder="Enter API key (optional)"
                   value="${(nodeData.config && nodeData.config.api_key) || ''}" />
            <p class="mt-1 text-xs text-gray-500">API key will be stored securely with this node's configuration.</p>
          </div>
        `;
      }

      console.log('Showing config modal');
      modal.classList.remove('hidden');
    };

    // Render dynamic input fields based on method inputs
    function renderInputFields(inputs, currentConfig) {
      const container = document.getElementById('config-inputs-container');
      container.innerHTML = '';

      if (!inputs || Object.keys(inputs).length === 0) {
        container.innerHTML = '<p class="text-sm text-gray-500 italic">This method has no configurable inputs.</p>';
        return;
      }

      Object.entries(inputs).forEach(([inputKey, inputDef]) => {
        const fieldDiv = document.createElement('div');

        const label = document.createElement('label');
        label.htmlFor = `config-input-${inputKey}`;
        label.className = 'block text-sm font-medium text-gray-700';
        label.textContent = inputKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        if (inputDef.required) {
          label.innerHTML += ' <span class="text-red-500">*</span>';
        }
        fieldDiv.appendChild(label);

        let inputEl;
        const currentValue = currentConfig[inputKey] !== undefined ? currentConfig[inputKey] : (inputDef.default || '');

        if (inputDef.type === 'string' && inputKey === 'operator') {
          // Special case: operator dropdown
          inputEl = document.createElement('select');
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm';
          ['equals', 'contains', 'greater_than', 'less_than'].forEach(op => {
            const opt = document.createElement('option');
            opt.value = op;
            opt.textContent = op.replace(/_/g, ' ');
            if (currentValue === op) opt.selected = true;
            inputEl.appendChild(opt);
          });
        } else if (inputDef.type === 'object') {
          // For object types, use textarea with JSON
          inputEl = document.createElement('textarea');
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm font-mono text-xs';
          inputEl.rows = 4;
          inputEl.placeholder = 'Enter JSON object, e.g., {"old_field": "new_field"}';
          inputEl.value = typeof currentValue === 'object' ? JSON.stringify(currentValue, null, 2) : currentValue;
        } else if (inputDef.type === 'integer') {
          inputEl = document.createElement('input');
          inputEl.type = 'number';
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm';
          inputEl.value = currentValue;
        } else {
          inputEl = document.createElement('input');
          inputEl.type = 'text';
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm';
          inputEl.value = currentValue;
        }

        inputEl.id = `config-input-${inputKey}`;
        inputEl.name = inputKey;
        if (inputDef.required) inputEl.required = true;

        fieldDiv.appendChild(inputEl);

        // Add help text if default value exists
        if (inputDef.default !== undefined) {
          const helpText = document.createElement('p');
          helpText.className = 'mt-1 text-xs text-gray-500';
          helpText.textContent = `Default: ${inputDef.default}`;
          fieldDiv.appendChild(helpText);
        }

        container.appendChild(fieldDiv);
      });
    }

    // Handle form submission
    document.getElementById('node-config-form').addEventListener('submit', function(e) {
      e.preventDefault();

      if (!currentConfigNodeId) return;

      const formData = new FormData(this);
      const config = {};

      // Get method
      const method = formData.get('method');
      if (method) {
        config.method = method;
      }

      // Get all input fields from the inputs container
      const inputsContainer = document.getElementById('config-inputs-container');
      const inputs = inputsContainer.querySelectorAll('input, select, textarea');
      inputs.forEach(input => {
        if (input.name && input.value !== '') {
          // Try to parse JSON for object fields
          if (input.tagName === 'TEXTAREA') {
            try {
              config[input.name] = JSON.parse(input.value);
            } catch {
              config[input.name] = input.value;
            }
          } else if (input.type === 'number') {
            config[input.name] = parseInt(input.value, 10);
          } else {
            config[input.name] = input.value;
          }
        }
      });

      // Get API key if present
      const apiKeyInput = document.getElementById('config-api-key');
      if (apiKeyInput && apiKeyInput.value) {
        config.api_key = apiKeyInput.value;
      }

      // Get label
      const label = formData.get('label');

      // Save configuration
      const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
      const serviceName = currentConfigNodeData?.service_name || formData.get('service_name');

      fetch(`${updateNodeConfigUrl}?node_id=${encodeURIComponent(currentConfigNodeId)}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken,
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          config: config,
          label: label,
          service_name: serviceName
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Update the node in React Flow state
          if (window.workflowSetNodes) {
            window.workflowSetNodes(nodes => nodes.map(node => {
              if (node.id === currentConfigNodeId) {
                return {
                  ...node,
                  data: {
                    ...node.data,
                    label: label || node.data.label,
                    config: config
                  }
                };
              }
              return node;
            }));
          }

          // Close modal
          document.getElementById('node-config-modal').classList.add('hidden');

          // Show success feedback
          console.log('Node configuration saved successfully');
        } else {
          alert('Error saving configuration: ' + (data.error || 'Unknown error'));
        }
      })
      .catch(error => {
        console.error('Error saving node configuration:', error);
        alert('Error saving configuration: ' + error.message);
      });
    });

    // Render React Flow
    const rootEl = document.getElementById('react-flow-root');
    if (!rootEl) {
      console.error('React Flow root element not found');
      return;
    }

    if (!ReactFlowProvider) {
      rootEl.innerHTML = '<div class="p-4 text-red-600">Error: React Flow Provider not loaded. Please refresh the page.</div>';
      return;
    }

    try {
      // Unmount existing root if present
      if (reactFlowRoot) {
        try {
          reactFlowRoot.unmount();
        } catch (e) {
          console.log('Previous root cleanup:', e.message);
        }
      }

      // Clear the container before creating new root
      rootEl.innerHTML = '';

      reactFlowRoot = ReactDOM.createRoot(rootEl);
      reactFlowRoot.render(
        React.createElement(ReactFlowProvider, null,
          React.createElement(WorkflowBuilder)
        )
      );

      // Setup click-to-add handlers after React renders
      setTimeout(() => {
        setupAddNodeButtons();
      }, 500);

      function setupAddNodeButtons() {
        const addButtons = document.querySelectorAll('.add-node-btn');
        console.log('Setting up', addButtons.length, 'add node buttons');

        addButtons.forEach(btn => {
          // Remove existing listeners by cloning
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);

          newBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const serviceKey = newBtn.dataset.serviceKey;
            const serviceName = newBtn.dataset.serviceName;

            console.log('Add button clicked for:', serviceKey);

            if (!window.addWorkflowNode) {
              console.error('addWorkflowNode not available yet');
              alert('Please wait for the canvas to load');
              return;
            }

            // Call the exposed function
            window.addWorkflowNode(serviceKey, serviceName);

            // Visual feedback
            newBtn.classList.add('scale-90');
            setTimeout(() => newBtn.classList.remove('scale-90'), 150);
          });
        });

        console.log('Add node buttons setup complete');
      }

    } catch (error) {
      console.error('Error rendering React Flow:', error);
      rootEl.innerHTML = `<div class="p-4 text-red-600">Error rendering workflow builder: ${error.message}</div>`;
    }
    } // End of initWorkflowBuilder function

    // Expose for re-initialization
    window._initWorkflowBuilder = initWorkflowBuilder;

    // Initialize on page load and Turbo navigation
    function handlePageLoad() {
      // Reset initialized flag when navigating to a new page
      initialized = false;
      // Small delay to ensure DOM is ready and scripts are loaded
      setTimeout(initWorkflowBuilder, 100);
    }

    // Run on initial load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', handlePageLoad);
    } else {
      handlePageLoad();
    }

    // Run on Turbo navigation
    document.addEventListener('turbo:load', handlePageLoad);
    document.addEventListener('turbo:render', handlePageLoad);

    // Cleanup when navigating away
    document.addEventListener('turbo:before-cache', function() {
      // Unmount React root before caching
      if (reactFlowRoot) {
        try {
          reactFlowRoot.unmount();
          reactFlowRoot = null;
        } catch (e) {
          console.log('React root cleanup:', e.message);
        }
      }
      initialized = false;
      window._currentWorkflowId = null;
      // Clean up global functions
      delete window.addWorkflowNode;
      delete window.workflowSetNodes;
      delete window.openNodeConfigModal;
      delete window._initWorkflowBuilder;
      // Reset listener flag so it can be re-attached on next workflow page
      window._workflowBuilderListenersAttached = false;
    });
  })();
</script>
