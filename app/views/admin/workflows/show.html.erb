<div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8">
  <div class="mb-6 flex justify-between items-center">
    <div>
      <h1 class="text-3xl font-bold text-gray-900"><%= @workflow.name %></h1>
      <p class="mt-2 text-sm text-gray-600"><%= @workflow.description %></p>
    </div>
    <div class="flex space-x-3">
      <%= link_to "Back to Workflows", admin_workflows_path, class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50" %>
      <%= link_to "View Results", results_admin_workflow_path(@workflow), class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700" %>
      <%= button_to "Execute Workflow", execute_admin_workflow_path(@workflow), method: :post, class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700" %>
    </div>
  </div>

  <!-- Workflow Builder with Sidebar -->
  <div class="bg-white shadow rounded-lg mb-6 overflow-hidden">
    <div class="flex" style="height: 800px;">
      <!-- Services Sidebar -->
      <div class="w-64 bg-gray-50 border-r border-gray-200 overflow-y-auto flex-shrink-0">
        <div class="p-4 border-b border-gray-200">
          <h3 class="text-sm font-semibold text-gray-900 uppercase tracking-wide">Available Services</h3>
          <p class="mt-1 text-xs text-gray-500">Click + to add to canvas</p>
        </div>
        <div class="p-2 space-y-2" id="services-sidebar">
          <% @service_info.each do |service_key, service_data| %>
            <div
              class="service-item p-3 bg-white rounded-lg border border-gray-200 shadow-sm hover:shadow-md transition-shadow"
              data-service-key="<%= service_key %>"
              data-service-name="<%= service_data[:name] %>">
              <div class="flex items-center space-x-2">
                <div class="flex-shrink-0">
                  <div class="w-8 h-8 bg-red-100 rounded flex items-center justify-center">
                    <svg class="w-5 h-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                    </svg>
                  </div>
                </div>
                <div class="flex-1 min-w-0">
                  <p class="text-sm font-medium text-gray-900 truncate"><%= service_data[:name] %></p>
                  <p class="text-xs text-gray-500 truncate"><%= service_data[:description] %></p>
                </div>
                <button
                  type="button"
                  class="add-node-btn flex-shrink-0 w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full flex items-center justify-center transition-colors"
                  data-service-key="<%= service_key %>"
                  data-service-name="<%= service_data[:name] %>"
                  title="Add to canvas">
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                  </svg>
                </button>
              </div>
            </div>
          <% end %>
        </div>
      </div>

      <!-- React Flow Canvas -->
      <div class="flex-1 relative" id="react-flow-container" style="min-width: 0; width: 100%; height: 100%; overflow: hidden;">
        <div id="workflow-builder"
             data-workflow-id="<%= @workflow.id %>"
             data-workflow-data="<%= @workflow_data.to_json %>"
             data-services="<%= @service_info.to_json %>"
             data-update-url="<%= admin_workflow_path(@workflow) %>"
             data-node-data-url="<%= node_data_admin_workflow_path(@workflow) %>"
             data-update-node-config-url="<%= update_node_config_admin_workflow_path(@workflow) %>"
             style="width: 100%; height: 100%; position: relative;">
          <div id="react-flow-root" style="width: 100%; height: 100%; background: #f9fafb; position: relative;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Recent Executions -->
  <div class="bg-white shadow rounded-lg">
    <div class="px-4 py-5 sm:px-6">
      <h3 class="text-lg leading-6 font-medium text-gray-900">Recent Executions</h3>
    </div>
    <div class="border-t border-gray-200">
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Started</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Records</th>
            <th scope="col" class="relative px-6 py-3"><span class="sr-only">View</span></th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
          <% @executions.each do |execution| %>
            <tr class="hover:bg-gray-50">
              <td class="px-6 py-4 whitespace-nowrap">
                <% case execution.status %>
                <% when 'completed' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">Completed</span>
                <% when 'failed' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-red-100 text-red-800">Failed</span>
                <% when 'running' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-blue-100 text-blue-800">Running</span>
                <% else %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-gray-100 text-gray-800">Pending</span>
                <% end %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.started_at ? time_ago_in_words(execution.started_at) + " ago" : "N/A" %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.duration ? "#{execution.duration.round(2)}s" : "N/A" %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.records_processed || 0 %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                <%= link_to "View", results_admin_workflow_path(@workflow, execution_id: execution.id), class: "text-red-600 hover:text-red-900" %>
              </td>
            </tr>
          <% end %>
        </tbody>
      </table>
    </div>
  </div>
</div>

<!-- Node Data Modal -->
<div id="node-data-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
  <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
    <div class="mt-3">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-medium text-gray-900" id="node-data-title">Node Data Output</h3>
        <button id="close-node-modal-btn" type="button" class="text-gray-400 hover:text-gray-600">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      <div id="node-data-content" class="max-h-96 overflow-y-auto">
        <div class="text-center py-8 text-gray-500">
          <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
          <p class="mt-2">Loading data...</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Node Configuration Modal -->
<div id="node-config-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
  <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-xl shadow-lg rounded-md bg-white">
    <div class="mt-3">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-medium text-gray-900" id="node-config-title">Configure Node</h3>
        <button id="close-config-modal-btn" type="button" class="text-gray-400 hover:text-gray-600">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      <form id="node-config-form" class="space-y-4">
        <input type="hidden" id="config-node-id" name="node_id" />
        <input type="hidden" id="config-service-name" name="service_name" />

        <!-- Node Label -->
        <div>
          <label for="config-node-label" class="block text-sm font-medium text-gray-700">Node Label</label>
          <input type="text" id="config-node-label" name="label"
                 class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm"
                 placeholder="Enter a custom label for this node" />
        </div>

        <!-- Method Selection -->
        <div>
          <label for="config-method" class="block text-sm font-medium text-gray-700">Method</label>
          <select id="config-method" name="method"
                  class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm">
            <option value="">Select a method...</option>
          </select>
          <p id="method-description" class="mt-1 text-xs text-gray-500"></p>
        </div>

        <!-- Dynamic Input Fields Container -->
        <div id="config-inputs-container" class="space-y-4">
          <!-- Dynamic fields will be inserted here -->
        </div>

        <!-- API Key Section (for services that need it) -->
        <div id="api-key-section" class="hidden border-t pt-4 mt-4">
          <h4 class="text-sm font-medium text-gray-700 mb-2">API Configuration</h4>
          <div id="api-key-fields" class="space-y-3">
            <!-- API key fields will be inserted here -->
          </div>
        </div>

        <!-- Form Actions -->
        <div class="flex justify-end space-x-3 pt-4 border-t">
          <button type="button" id="cancel-config-btn"
                  class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50">
            Cancel
          </button>
          <button type="submit"
                  class="px-4 py-2 text-sm font-medium text-white bg-red-600 border border-transparent rounded-md hover:bg-red-700">
            Save Configuration
          </button>
        </div>
      </form>
    </div>
  </div>
</div>

<%= stylesheet_link_tag "https://unpkg.com/reactflow@11/dist/style.css" %>
<%= javascript_include_tag "https://unpkg.com/react@18/umd/react.development.js" %>
<%= javascript_include_tag "https://unpkg.com/react-dom@18/umd/react-dom.development.js" %>
<%= javascript_include_tag "https://unpkg.com/reactflow@11/dist/umd/index.js" %>

<script>
  (function() {
    const builderEl = document.getElementById('workflow-builder');
    if (!builderEl) return;

    const workflowData = JSON.parse(builderEl.dataset.workflowData || '{"nodes":[],"edges":[]}');
    const services = JSON.parse(builderEl.dataset.services || '{}');
    const updateUrl = builderEl.dataset.updateUrl;
    const nodeDataUrlTemplate = builderEl.dataset.nodeDataUrl;
    const updateNodeConfigUrl = builderEl.dataset.updateNodeConfigUrl;
    const workflowId = builderEl.dataset.workflowId;

    const { React, ReactDOM } = window;
    const ReactFlow = window.ReactFlow;

    if (!React || !ReactDOM || !ReactFlow) {
      console.error('React Flow not loaded');
      return;
    }

    const { useCallback, useState, useRef, useEffect, useMemo } = React;

    // React Flow v11 UMD build - get components
    const FlowLib = window.ReactFlow;
    console.log('ReactFlow keys:', Object.keys(FlowLib || {}));

    const ReactFlowProvider = FlowLib.ReactFlowProvider;
    const useReactFlow = FlowLib.useReactFlow;
    const applyNodeChanges = FlowLib.applyNodeChanges;
    const applyEdgeChanges = FlowLib.applyEdgeChanges;
    const addEdge = FlowLib.addEdge;
    const Background = FlowLib.Background;
    const Controls = FlowLib.Controls;
    const MiniMap = FlowLib.MiniMap;
    const Handle = FlowLib.Handle;
    const Position = FlowLib.Position || { Left: 'left', Right: 'right', Top: 'top', Bottom: 'bottom' };
    const ReactFlowComponent = FlowLib.default || FlowLib.ReactFlow;

    console.log('React Flow components:', {
      ReactFlowProvider: !!ReactFlowProvider,
      applyNodeChanges: !!applyNodeChanges,
      applyEdgeChanges: !!applyEdgeChanges,
      ReactFlowComponent: !!ReactFlowComponent
    });

    // Global state for node config modal
    window.nodeConfigState = {};

    // Simple custom node using default React Flow patterns
    function ServiceNode({ data, id }) {
      const configuredMethod = data.config?.method;

      return React.createElement('div', {
        style: {
          padding: 10,
          borderRadius: 5,
          background: 'white',
          border: '2px solid #ef4444',
          minWidth: 150
        }
      }, [
        // Handles for connections
        Handle && React.createElement(Handle, {
          key: 'target',
          type: 'target',
          position: Position.Left,
          style: { background: '#3b82f6' }
        }),
        Handle && React.createElement(Handle, {
          key: 'source',
          type: 'source',
          position: Position.Right,
          style: { background: '#ef4444' }
        }),
        // Content
        React.createElement('div', { key: 'content' }, [
          React.createElement('div', {
            key: 'header',
            style: { display: 'flex', justifyContent: 'space-between', alignItems: 'center' }
          }, [
            React.createElement('strong', { key: 'label' }, data.label || 'Node'),
            React.createElement('span', {
              key: 'config',
              className: 'nodrag',
              onClick: (e) => {
                e.stopPropagation();
                console.log('Config clicked:', id);
                const event = new CustomEvent('openNodeConfig', { detail: { nodeId: id, nodeData: data } });
                document.dispatchEvent(event);
              },
              style: { cursor: 'pointer', padding: '2px 6px' }
            }, '⚙️')
          ]),
          React.createElement('div', {
            key: 'service',
            style: { fontSize: 11, color: '#666', marginTop: 4 }
          }, data.service_name || ''),
          React.createElement('div', {
            key: 'method',
            style: { fontSize: 10, color: '#999', marginTop: 2 }
          }, configuredMethod ? `Method: ${configuredMethod}` : 'Configure →'),
          React.createElement('div', {
            key: 'view',
            className: 'nodrag',
            onClick: (e) => {
              e.stopPropagation();
              console.log('View clicked:', id);
              const modal = document.getElementById('node-data-modal');
              const contentDiv = document.getElementById('node-data-content');
              if (modal) {
                document.getElementById('node-data-title').textContent = data.label + ' - Output';
                // Reset to loading state
                contentDiv.innerHTML = `
                  <div class="text-center py-8 text-gray-500">
                    <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
                    <p class="mt-2">Loading data...</p>
                  </div>
                `;
                modal.classList.remove('hidden');

                // Fetch node data from backend
                const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
                fetch(`${nodeDataUrlTemplate}?node_id=${encodeURIComponent(id)}`, {
                  method: 'GET',
                  headers: {
                    'Accept': 'application/json',
                    'X-CSRF-Token': csrfToken
                  }
                })
                .then(response => response.json())
                .then(result => {
                  if (result.error) {
                    contentDiv.innerHTML = `
                      <div class="text-center py-8 text-red-500">
                        <p>Error: ${result.error}</p>
                      </div>
                    `;
                    return;
                  }

                  // Build the display content
                  let html = '';

                  // Show node config summary
                  if (result.node) {
                    html += `<div class="mb-4 p-3 bg-gray-50 rounded-lg">
                      <h4 class="font-medium text-gray-700 mb-2">Node Configuration</h4>
                      <p class="text-sm text-gray-600"><strong>Service:</strong> ${result.node.service_name || 'N/A'}</p>
                      <p class="text-sm text-gray-600"><strong>Method:</strong> ${result.node.config?.method || 'Not configured'}</p>
                    </div>`;
                  }

                  // Show message if no data
                  if (result.message) {
                    html += `<div class="text-center py-4 text-gray-500">
                      <p>${result.message}</p>
                    </div>`;
                  }

                  // Show execution status
                  if (result.execution_status) {
                    const statusColors = {
                      'completed': 'bg-green-100 text-green-800',
                      'failed': 'bg-red-100 text-red-800',
                      'running': 'bg-blue-100 text-blue-800',
                      'pending': 'bg-gray-100 text-gray-800'
                    };
                    html += `<div class="mb-4">
                      <span class="px-2 py-1 text-xs font-semibold rounded-full ${statusColors[result.execution_status] || 'bg-gray-100 text-gray-800'}">
                        Execution: ${result.execution_status}
                      </span>
                    </div>`;
                  }

                  // Show data results
                  if (result.data && Array.isArray(result.data) && result.data.length > 0) {
                    html += `<div class="mb-2 text-sm text-gray-600">
                      <strong>Results:</strong> ${result.data.length} records
                    </div>`;
                    html += `<div class="overflow-x-auto">
                      <pre class="bg-gray-900 text-green-400 p-4 rounded-lg text-xs overflow-auto max-h-64">${JSON.stringify(result.data.slice(0, 50), null, 2)}</pre>
                    </div>`;
                    if (result.data.length > 50) {
                      html += `<p class="mt-2 text-xs text-gray-500">Showing first 50 of ${result.data.length} records</p>`;
                    }
                  } else if (result.data && typeof result.data === 'object' && Object.keys(result.data).length > 0) {
                    html += `<div class="overflow-x-auto">
                      <pre class="bg-gray-900 text-green-400 p-4 rounded-lg text-xs overflow-auto max-h-64">${JSON.stringify(result.data, null, 2)}</pre>
                    </div>`;
                  } else if (!result.message) {
                    html += `<div class="text-center py-4 text-gray-500">
                      <p>No output data available. Execute the workflow to see results.</p>
                    </div>`;
                  }

                  contentDiv.innerHTML = html;
                })
                .catch(error => {
                  console.error('Error fetching node data:', error);
                  contentDiv.innerHTML = `
                    <div class="text-center py-8 text-red-500">
                      <p>Error loading data: ${error.message}</p>
                    </div>
                  `;
                });
              }
            },
            style: {
              marginTop: 8,
              padding: '4px 8px',
              background: '#f0f0f0',
              borderRadius: 3,
              fontSize: 11,
              textAlign: 'center',
              cursor: 'pointer'
            }
          }, 'View Output')
        ])
      ]);
    }

    // Node types - must be defined outside component and be stable
    const nodeTypes = { service: ServiceNode };

    // Main workflow builder component - using controlled mode with applyNodeChanges
    const WorkflowBuilder = () => {
      // Use regular useState - we'll manually apply changes
      const [nodes, setNodes] = useState(workflowData.nodes || []);
      const [edges, setEdges] = useState(workflowData.edges || []);

      const reactFlowWrapper = useRef(null);

      // Track latest state in refs for async operations
      const nodesRef = useRef(nodes);
      const edgesRef = useRef(edges);
      useEffect(() => {
        nodesRef.current = nodes;
        edgesRef.current = edges;
      }, [nodes, edges]);

      console.log('WorkflowBuilder render - nodes:', nodes.length, 'edges:', edges.length);

      // Handle node changes (including drag)
      const onNodesChange = useCallback((changes) => {
        // Log all changes with full details for debugging
        changes.forEach(c => {
          console.log('Node change:', c.type, c.id, c.type === 'position' ? c.position : '');
        });

        if (applyNodeChanges) {
          setNodes((nds) => {
            const result = applyNodeChanges(changes, nds);
            return result;
          });
        } else {
          console.warn('applyNodeChanges not available, using fallback');
          setNodes((nds) => {
            let updated = [...nds];
            changes.forEach(change => {
              if (change.type === 'position' && change.position) {
                const idx = updated.findIndex(n => n.id === change.id);
                if (idx !== -1) {
                  updated[idx] = { ...updated[idx], position: change.position };
                }
              }
            });
            return updated;
          });
        }
      }, []);

      // Handle edge changes
      const onEdgesChange = useCallback((changes) => {
        if (applyEdgeChanges) {
          setEdges((eds) => applyEdgeChanges(changes, eds));
        }
      }, []);

      // Handle new connections
      const onConnect = useCallback((connection) => {
        console.log('onConnect:', connection);
        if (addEdge) {
          setEdges((eds) => addEdge(connection, eds));
        } else {
          const newEdge = { ...connection, id: `edge-${Date.now()}` };
          setEdges((eds) => [...eds, newEdge]);
        }
      }, []);

      // Save workflow
      const saveWorkflow = useCallback(() => {
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
        if (!csrfToken) return;

        fetch(updateUrl, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken,
            'Accept': 'application/json'
          },
          body: JSON.stringify({
            workflow: {
              workflow_data: {
                nodes: nodesRef.current,
                edges: edgesRef.current
              }
            }
          })
        })
        .then(r => r.json())
        .then(() => console.log('Saved'))
        .catch(e => console.error('Save error:', e));
      }, []);

      // Track when dragging starts
      const onNodeDragStart = useCallback((event, node) => {
        console.log('>>> DRAG STARTED:', node.id, node.position);
      }, []);

      // Track during drag
      const onNodeDrag = useCallback((event, node) => {
        console.log('>>> DRAGGING:', node.id, node.position);
      }, []);

      // Save on drag end
      const onNodeDragStop = useCallback((event, node) => {
        console.log('>>> DRAG STOPPED:', node.id, node.position);
        setTimeout(saveWorkflow, 100);
      }, [saveWorkflow]);

      // Add new node function
      const addNode = useCallback((serviceKey, serviceName) => {
        console.log('Adding node:', serviceKey);

        const currentNodes = nodesRef.current;
        let position = { x: 100, y: 100 };
        if (currentNodes.length > 0) {
          const maxX = Math.max(...currentNodes.map(n => n.position?.x || 0));
          position = { x: maxX + 280, y: 100 };
        }

        const serviceInfo = services[serviceKey];
        const newNode = {
          id: `node-${Date.now()}`,
          type: 'service',
          position,
          data: {
            label: serviceInfo?.name || serviceName,
            service_name: serviceKey,
            config: {}
          }
        };

        setNodes(nds => [...nds, newNode]);
        setTimeout(saveWorkflow, 200);
      }, [saveWorkflow]);

      // Expose to window
      useEffect(() => {
        window.addWorkflowNode = addNode;
        window.workflowSetNodes = setNodes;
        return () => {
          delete window.addWorkflowNode;
          delete window.workflowSetNodes;
        };
      }, [addNode]);

      // Memoize node types to prevent re-renders
      const memoizedNodeTypes = useMemo(() => nodeTypes, []);

      if (!ReactFlowComponent) {
        return React.createElement('div', { style: { padding: 20, color: 'red' } },
          'Error: React Flow not loaded'
        );
      }

      return React.createElement('div', {
        ref: reactFlowWrapper,
        style: { width: '100%', height: '100%', position: 'absolute', top: 0, left: 0 }
      },
        React.createElement(ReactFlowComponent, {
          nodes: nodes,
          edges: edges,
          onNodesChange: onNodesChange,
          onEdgesChange: onEdgesChange,
          onConnect: onConnect,
          onNodeDragStart: onNodeDragStart,
          onNodeDrag: onNodeDrag,
          onNodeDragStop: onNodeDragStop,
          nodeTypes: memoizedNodeTypes,
          fitView: true,
          fitViewOptions: { padding: 0.3 },
          defaultEdgeOptions: { type: 'smoothstep', style: { stroke: '#ef4444', strokeWidth: 2 } },
          minZoom: 0.1,
          maxZoom: 2,
          proOptions: { hideAttribution: true }
        }, [
          Background && React.createElement(Background, { key: 'bg', variant: 'dots', gap: 20, size: 1 }),
          Controls && React.createElement(Controls, { key: 'ctrl' }),
          MiniMap && React.createElement(MiniMap, { key: 'mm', nodeColor: '#ef4444' })
        ])
      );
    };

    // Setup modal close handlers
    function setupModalHandlers() {
      const modal = document.getElementById('node-data-modal');
      const closeBtn = document.getElementById('close-node-modal-btn');

      if (closeBtn) {
        closeBtn.onclick = () => {
          if (modal) modal.classList.add('hidden');
        };
      }

      if (modal) {
        modal.onclick = (e) => {
          if (e.target === modal) {
            modal.classList.add('hidden');
          }
        };
      }

      // Config modal handlers
      const configModal = document.getElementById('node-config-modal');
      const closeConfigBtn = document.getElementById('close-config-modal-btn');
      const cancelConfigBtn = document.getElementById('cancel-config-btn');

      if (closeConfigBtn) {
        closeConfigBtn.onclick = () => {
          if (configModal) configModal.classList.add('hidden');
        };
      }

      if (cancelConfigBtn) {
        cancelConfigBtn.onclick = () => {
          if (configModal) configModal.classList.add('hidden');
        };
      }

      if (configModal) {
        configModal.onclick = (e) => {
          if (e.target === configModal) {
            configModal.classList.add('hidden');
          }
        };
      }
    }

    setupModalHandlers();

    // Re-setup after Turbo navigation
    document.addEventListener('turbo:load', setupModalHandlers);
    document.addEventListener('turbo:render', setupModalHandlers);

    // Node configuration modal functions
    let currentConfigNodeId = null;
    let currentConfigNodeData = null;

    // Listen for custom event from React component
    document.addEventListener('openNodeConfig', function(e) {
      console.log('openNodeConfig event received:', e.detail);
      if (e.detail && e.detail.nodeId) {
        window.openNodeConfigModal(e.detail.nodeId, e.detail.nodeData);
      }
    });

    // Open the node configuration modal
    window.openNodeConfigModal = function(nodeId, nodeData) {
      console.log('openNodeConfigModal called with:', nodeId, nodeData);
      currentConfigNodeId = nodeId;
      currentConfigNodeData = nodeData;

      const modal = document.getElementById('node-config-modal');
      const title = document.getElementById('node-config-title');
      const nodeIdField = document.getElementById('config-node-id');
      const serviceNameField = document.getElementById('config-service-name');
      const labelField = document.getElementById('config-node-label');
      const methodSelect = document.getElementById('config-method');
      const methodDescription = document.getElementById('method-description');
      const inputsContainer = document.getElementById('config-inputs-container');
      const apiKeySection = document.getElementById('api-key-section');
      const apiKeyFields = document.getElementById('api-key-fields');

      if (!modal) {
        console.error('Config modal element not found!');
        return;
      }
      console.log('Modal element found, proceeding...');

      // Set title and hidden fields
      title.textContent = `Configure: ${nodeData.label || nodeData.service_name || 'Node'}`;
      nodeIdField.value = nodeId;
      serviceNameField.value = nodeData.service_name || '';
      labelField.value = nodeData.label || '';

      // Get service info for this node
      const serviceName = nodeData.service_name;
      const serviceInfo = services[serviceName];

      // Clear and populate method dropdown
      methodSelect.innerHTML = '<option value="">Select a method...</option>';
      methodDescription.textContent = '';
      inputsContainer.innerHTML = '';

      if (serviceInfo && serviceInfo.methods) {
        Object.entries(serviceInfo.methods).forEach(([methodKey, methodInfo]) => {
          const option = document.createElement('option');
          option.value = methodKey;
          option.textContent = methodInfo.name || methodKey;
          // Select current method if configured
          if (nodeData.config && nodeData.config.method === methodKey) {
            option.selected = true;
          }
          methodSelect.appendChild(option);
        });

        // If a method is selected, show its description and inputs
        if (nodeData.config && nodeData.config.method) {
          const selectedMethod = serviceInfo.methods[nodeData.config.method];
          if (selectedMethod) {
            methodDescription.textContent = selectedMethod.description || '';
            renderInputFields(selectedMethod.inputs || {}, nodeData.config || {});
          }
        }
      }

      // Handle method selection change
      methodSelect.onchange = function() {
        const selectedMethodKey = this.value;
        inputsContainer.innerHTML = '';
        methodDescription.textContent = '';

        if (selectedMethodKey && serviceInfo && serviceInfo.methods && serviceInfo.methods[selectedMethodKey]) {
          const methodInfo = serviceInfo.methods[selectedMethodKey];
          methodDescription.textContent = methodInfo.description || '';
          renderInputFields(methodInfo.inputs || {}, nodeData.config || {});
        }
      };

      // Handle API key section for services that need it
      apiKeySection.classList.add('hidden');
      apiKeyFields.innerHTML = '';

      if (serviceName === 'abuse_ch' || serviceName === 'abuseipdb') {
        apiKeySection.classList.remove('hidden');
        const apiKeyName = serviceName === 'abuse_ch' ? 'abuse_ch_api_key' : 'abuseipdb_api_key';
        const apiKeyLabel = serviceName === 'abuse_ch' ? 'abuse.ch API Key' : 'AbuseIPDB API Key';

        apiKeyFields.innerHTML = `
          <div>
            <label for="config-api-key" class="block text-sm font-medium text-gray-700">${apiKeyLabel}</label>
            <input type="password" id="config-api-key" name="api_key"
                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm"
                   placeholder="Enter API key (optional)"
                   value="${(nodeData.config && nodeData.config.api_key) || ''}" />
            <p class="mt-1 text-xs text-gray-500">API key will be stored securely with this node's configuration.</p>
          </div>
        `;
      }

      console.log('Showing config modal');
      modal.classList.remove('hidden');
    };

    // Render dynamic input fields based on method inputs
    function renderInputFields(inputs, currentConfig) {
      const container = document.getElementById('config-inputs-container');
      container.innerHTML = '';

      if (!inputs || Object.keys(inputs).length === 0) {
        container.innerHTML = '<p class="text-sm text-gray-500 italic">This method has no configurable inputs.</p>';
        return;
      }

      Object.entries(inputs).forEach(([inputKey, inputDef]) => {
        const fieldDiv = document.createElement('div');

        const label = document.createElement('label');
        label.htmlFor = `config-input-${inputKey}`;
        label.className = 'block text-sm font-medium text-gray-700';
        label.textContent = inputKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        if (inputDef.required) {
          label.innerHTML += ' <span class="text-red-500">*</span>';
        }
        fieldDiv.appendChild(label);

        let inputEl;
        const currentValue = currentConfig[inputKey] !== undefined ? currentConfig[inputKey] : (inputDef.default || '');

        if (inputDef.type === 'string' && inputKey === 'operator') {
          // Special case: operator dropdown
          inputEl = document.createElement('select');
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm';
          ['equals', 'contains', 'greater_than', 'less_than'].forEach(op => {
            const opt = document.createElement('option');
            opt.value = op;
            opt.textContent = op.replace(/_/g, ' ');
            if (currentValue === op) opt.selected = true;
            inputEl.appendChild(opt);
          });
        } else if (inputDef.type === 'object') {
          // For object types, use textarea with JSON
          inputEl = document.createElement('textarea');
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm font-mono text-xs';
          inputEl.rows = 4;
          inputEl.placeholder = 'Enter JSON object, e.g., {"old_field": "new_field"}';
          inputEl.value = typeof currentValue === 'object' ? JSON.stringify(currentValue, null, 2) : currentValue;
        } else if (inputDef.type === 'integer') {
          inputEl = document.createElement('input');
          inputEl.type = 'number';
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm';
          inputEl.value = currentValue;
        } else {
          inputEl = document.createElement('input');
          inputEl.type = 'text';
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm';
          inputEl.value = currentValue;
        }

        inputEl.id = `config-input-${inputKey}`;
        inputEl.name = inputKey;
        if (inputDef.required) inputEl.required = true;

        fieldDiv.appendChild(inputEl);

        // Add help text if default value exists
        if (inputDef.default !== undefined) {
          const helpText = document.createElement('p');
          helpText.className = 'mt-1 text-xs text-gray-500';
          helpText.textContent = `Default: ${inputDef.default}`;
          fieldDiv.appendChild(helpText);
        }

        container.appendChild(fieldDiv);
      });
    }

    // Handle form submission
    document.getElementById('node-config-form').addEventListener('submit', function(e) {
      e.preventDefault();

      if (!currentConfigNodeId) return;

      const formData = new FormData(this);
      const config = {};

      // Get method
      const method = formData.get('method');
      if (method) {
        config.method = method;
      }

      // Get all input fields from the inputs container
      const inputsContainer = document.getElementById('config-inputs-container');
      const inputs = inputsContainer.querySelectorAll('input, select, textarea');
      inputs.forEach(input => {
        if (input.name && input.value !== '') {
          // Try to parse JSON for object fields
          if (input.tagName === 'TEXTAREA') {
            try {
              config[input.name] = JSON.parse(input.value);
            } catch {
              config[input.name] = input.value;
            }
          } else if (input.type === 'number') {
            config[input.name] = parseInt(input.value, 10);
          } else {
            config[input.name] = input.value;
          }
        }
      });

      // Get API key if present
      const apiKeyInput = document.getElementById('config-api-key');
      if (apiKeyInput && apiKeyInput.value) {
        config.api_key = apiKeyInput.value;
      }

      // Get label
      const label = formData.get('label');

      // Save configuration
      const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
      const serviceName = currentConfigNodeData?.service_name || formData.get('service_name');

      fetch(`${updateNodeConfigUrl}?node_id=${encodeURIComponent(currentConfigNodeId)}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken,
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          config: config,
          label: label,
          service_name: serviceName
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Update the node in React Flow state
          if (window.workflowSetNodes) {
            window.workflowSetNodes(nodes => nodes.map(node => {
              if (node.id === currentConfigNodeId) {
                return {
                  ...node,
                  data: {
                    ...node.data,
                    label: label || node.data.label,
                    config: config
                  }
                };
              }
              return node;
            }));
          }

          // Close modal
          document.getElementById('node-config-modal').classList.add('hidden');

          // Show success feedback
          console.log('Node configuration saved successfully');
        } else {
          alert('Error saving configuration: ' + (data.error || 'Unknown error'));
        }
      })
      .catch(error => {
        console.error('Error saving node configuration:', error);
        alert('Error saving configuration: ' + error.message);
      });
    });

    // Render React Flow
    const rootEl = document.getElementById('react-flow-root');
    if (!rootEl) {
      console.error('React Flow root element not found');
      return;
    }
    
    if (!ReactFlowProvider) {
      rootEl.innerHTML = '<div class="p-4 text-red-600">Error: React Flow Provider not loaded. Please refresh the page.</div>';
      return;
    }
    
    try {
      const root = ReactDOM.createRoot(rootEl);
      root.render(
        React.createElement(ReactFlowProvider, null,
          React.createElement(WorkflowBuilder)
        )
      );

      // Setup click-to-add handlers after React renders
      setTimeout(() => {
        setupAddNodeButtons();
      }, 500);

      function setupAddNodeButtons() {
        const addButtons = document.querySelectorAll('.add-node-btn');
        console.log('Setting up', addButtons.length, 'add node buttons');

        addButtons.forEach(btn => {
          // Remove existing listeners by cloning
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);

          newBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const serviceKey = newBtn.dataset.serviceKey;
            const serviceName = newBtn.dataset.serviceName;

            console.log('Add button clicked for:', serviceKey);

            if (!window.addWorkflowNode) {
              console.error('addWorkflowNode not available yet');
              alert('Please wait for the canvas to load');
              return;
            }

            // Call the exposed function
            window.addWorkflowNode(serviceKey, serviceName);

            // Visual feedback
            newBtn.classList.add('scale-90');
            setTimeout(() => newBtn.classList.remove('scale-90'), 150);
          });
        });

        console.log('Add node buttons setup complete');
      }

    } catch (error) {
      console.error('Error rendering React Flow:', error);
      rootEl.innerHTML = `<div class="p-4 text-red-600">Error rendering workflow builder: ${error.message}</div>`;
    }
  })();
</script>
