<div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8">
  <div class="mb-6 flex justify-between items-center">
    <div>
      <h1 class="text-3xl font-bold text-gray-900"><%= @workflow.name %></h1>
      <p class="mt-2 text-sm text-gray-600"><%= @workflow.description %></p>
    </div>
    <div class="flex space-x-3">
      <%= link_to "Back to Workflows", admin_workflows_path, class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50" %>
      <%= link_to "View Results", results_admin_workflow_path(@workflow), class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700" %>
      <%= button_to "Execute Workflow", execute_admin_workflow_path(@workflow), method: :post, class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700" %>
    </div>
  </div>

  <!-- Workflow Builder with Sidebar -->
  <div class="bg-white shadow rounded-lg mb-6 overflow-hidden">
    <div class="flex" style="height: 800px;">
      <!-- Services Sidebar -->
      <div class="w-64 bg-gray-50 border-r border-gray-200 overflow-y-auto flex-shrink-0">
        <div class="p-4 border-b border-gray-200">
          <h3 class="text-sm font-semibold text-gray-900 uppercase tracking-wide">Available Services</h3>
          <p class="mt-1 text-xs text-gray-500">Drag to canvas</p>
        </div>
        <div class="p-2 space-y-2" id="services-sidebar">
          <% @service_info.each do |service_key, service_data| %>
            <div 
              class="service-item p-3 bg-white rounded-lg border border-gray-200 shadow-sm hover:shadow-md cursor-move transition-shadow"
              draggable="true"
              data-service-key="<%= service_key %>"
              data-service-name="<%= service_data[:name] %>"
              style="user-select: none;">
              <div class="flex items-center space-x-2">
                <div class="flex-shrink-0">
                  <div class="w-8 h-8 bg-red-100 rounded flex items-center justify-center">
                    <svg class="w-5 h-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                    </svg>
                  </div>
                </div>
                <div class="flex-1 min-w-0">
                  <p class="text-sm font-medium text-gray-900 truncate"><%= service_data[:name] %></p>
                  <p class="text-xs text-gray-500 truncate"><%= service_data[:description] %></p>
                </div>
              </div>
            </div>
          <% end %>
        </div>
      </div>

      <!-- React Flow Canvas -->
      <div class="flex-1 relative overflow-hidden" id="react-flow-container" style="min-width: 0;">
        <div id="workflow-builder" 
             data-workflow-id="<%= @workflow.id %>"
             data-workflow-data="<%= @workflow_data.to_json %>"
             data-services="<%= @service_info.to_json %>"
             data-update-url="<%= admin_workflow_path(@workflow) %>"
             data-node-data-url="<%= node_data_admin_workflow_path(@workflow) %>"
             class="h-full w-full">
          <div id="react-flow-root" class="h-full w-full" style="background: #f9fafb;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Recent Executions -->
  <div class="bg-white shadow rounded-lg">
    <div class="px-4 py-5 sm:px-6">
      <h3 class="text-lg leading-6 font-medium text-gray-900">Recent Executions</h3>
    </div>
    <div class="border-t border-gray-200">
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Started</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Records</th>
            <th scope="col" class="relative px-6 py-3"><span class="sr-only">View</span></th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
          <% @executions.each do |execution| %>
            <tr class="hover:bg-gray-50">
              <td class="px-6 py-4 whitespace-nowrap">
                <% case execution.status %>
                <% when 'completed' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">Completed</span>
                <% when 'failed' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-red-100 text-red-800">Failed</span>
                <% when 'running' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-blue-100 text-blue-800">Running</span>
                <% else %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-gray-100 text-gray-800">Pending</span>
                <% end %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.started_at ? time_ago_in_words(execution.started_at) + " ago" : "N/A" %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.duration ? "#{execution.duration.round(2)}s" : "N/A" %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.records_processed || 0 %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                <%= link_to "View", results_admin_workflow_path(@workflow, execution_id: execution.id), class: "text-red-600 hover:text-red-900" %>
              </td>
            </tr>
          <% end %>
        </tbody>
      </table>
    </div>
  </div>
</div>

<!-- Node Data Modal -->
<div id="node-data-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
  <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
    <div class="mt-3">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-medium text-gray-900" id="node-data-title">Node Data Output</h3>
        <button id="close-node-modal-btn" type="button" class="text-gray-400 hover:text-gray-600">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
      
      <div id="node-data-content" class="max-h-96 overflow-y-auto">
        <div class="text-center py-8 text-gray-500">
          <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
          <p class="mt-2">Loading data...</p>
        </div>
      </div>
    </div>
  </div>
</div>

<%= javascript_include_tag "https://unpkg.com/react@18/umd/react.development.js" %>
<%= javascript_include_tag "https://unpkg.com/react-dom@18/umd/react-dom.development.js" %>
<%= javascript_include_tag "https://unpkg.com/reactflow@11/dist/umd/index.js" %>

<script>
  (function() {
    const builderEl = document.getElementById('workflow-builder');
    if (!builderEl) return;

    const workflowData = JSON.parse(builderEl.dataset.workflowData || '{"nodes":[],"edges":[]}');
    const services = JSON.parse(builderEl.dataset.services || '{}');
    const updateUrl = builderEl.dataset.updateUrl;
    const nodeDataUrlTemplate = builderEl.dataset.nodeDataUrl;
    const workflowId = builderEl.dataset.workflowId;

    const { React, ReactDOM } = window;
    const ReactFlow = window.ReactFlow;

    if (!React || !ReactDOM || !ReactFlow) {
      console.error('React Flow not loaded');
      return;
    }

    const { useCallback, useState, useRef, useEffect } = React;
    
    // React Flow v11 / @xyflow/react UMD build structure
    // Check what's available
    console.log('ReactFlow/XYFlow object:', window.ReactFlow || window.XYFlow || ReactFlow);
    const FlowLib = window.ReactFlow || window.XYFlow || ReactFlow;
    console.log('FlowLib keys:', Object.keys(FlowLib || {}));
    
    // Try different possible structures
    const ReactFlowProvider = FlowLib?.ReactFlowProvider || FlowLib?.default?.ReactFlowProvider;
    const useReactFlow = FlowLib?.useReactFlow || FlowLib?.default?.useReactFlow;
    const Background = FlowLib?.Background || FlowLib?.default?.Background;
    const Controls = FlowLib?.Controls || FlowLib?.default?.Controls;
    const MiniMap = FlowLib?.MiniMap || FlowLib?.default?.MiniMap;
    const Handle = FlowLib?.Handle || FlowLib?.default?.Handle;
    const Position = FlowLib?.Position || FlowLib?.default?.Position || { 
      Left: 'left', 
      Right: 'right', 
      Top: 'top', 
      Bottom: 'bottom' 
    };
    const ReactFlowComponent = FlowLib?.ReactFlow || FlowLib?.default?.ReactFlow || FlowLib?.default;
    
    // Validate components
    if (!ReactFlowProvider || !useReactFlow || !Background || !Controls || !Handle || !ReactFlowComponent) {
      console.error('Missing React Flow components:', {
        ReactFlowProvider: !!ReactFlowProvider,
        useReactFlow: !!useReactFlow,
        Background: !!Background,
        Controls: !!Controls,
        Handle: !!Handle,
        ReactFlowComponent: !!ReactFlowComponent
      });
      console.error('Available ReactFlow keys:', Object.keys(ReactFlow || {}));
    } else {
      console.log('All React Flow components loaded successfully');
    }

    // Enhanced Service Node with click handler
    const ServiceNode = ({ data, id }) => {
      const handleClick = (e) => {
        e.stopPropagation();
        const modal = document.getElementById('node-data-modal');
        const title = document.getElementById('node-data-title');
        const content = document.getElementById('node-data-content');
        
        if (!modal || !title || !content) {
          console.error('Modal elements not found');
          return;
        }

        title.textContent = `${data.label || 'Node'} - Data Output`;
        content.innerHTML = '<div class="text-center py-8 text-gray-500"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div><p class="mt-2">Loading data...</p></div>';
        modal.classList.remove('hidden');

        // Fetch node data
        const url = `${nodeDataUrlTemplate}?node_id=${encodeURIComponent(id)}`;
        fetch(url, {
          headers: {
            'Accept': 'application/json',
            'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.content || ''
          }
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.json();
        })
        .then(data => {
          if (data.error) {
            content.innerHTML = `<div class="text-center py-8 text-red-600">${data.error}</div>`;
            return;
          }

          let html = '';
          if (data.data && Array.isArray(data.data) && data.data.length > 0) {
            html = '<div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr>';
            const firstItem = data.data[0];
            const keys = Object.keys(firstItem);
            keys.forEach(key => {
              html += `<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${key}</th>`;
            });
            html += '</tr></thead><tbody class="bg-white divide-y divide-gray-200">';
            
            data.data.slice(0, 100).forEach((item) => {
              html += '<tr class="hover:bg-gray-50">';
              keys.forEach(key => {
                let value = item[key];
                if (value === undefined || value === null) {
                  value = '';
                } else if (typeof value === 'object') {
                  value = JSON.stringify(value);
                } else {
                  value = String(value);
                }
                // Escape HTML
                value = value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                html += `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">${value}</td>`;
              });
              html += '</tr>';
            });
            html += '</tbody></table></div>';
            if (data.data.length > 100) {
              html += `<div class="mt-4 text-sm text-gray-500 text-center">Showing first 100 of ${data.data.length} records</div>`;
            }
          } else {
            html = `<div class="text-center py-8 text-gray-500">${data.message || 'No data available. Execute the workflow to see results.'}</div>`;
          }
          content.innerHTML = html;
        })
        .catch(error => {
          console.error('Error loading node data:', error);
          content.innerHTML = `<div class="text-center py-8 text-red-600">Error loading data: ${error.message}</div>`;
        });
      };

      const handlePosition = Position?.Right || 'right';
      const targetPosition = Position?.Left || 'left';
      
      return React.createElement('div', {
        className: 'px-4 py-3 shadow-lg rounded-lg bg-white border-2 border-red-500 hover:border-red-600 cursor-pointer transition-all',
        style: { 
          width: 220, 
          minHeight: 80,
          position: 'relative',
          zIndex: 1,
          boxSizing: 'border-box',
          backgroundColor: 'white'
        },
        onClick: handleClick,
        'data-node-id': id
      }, [
        Handle ? React.createElement(Handle, { 
          key: 'source', 
          type: 'source', 
          position: handlePosition, 
          id: 'source',
          className: 'w-3 h-3 bg-red-500',
          style: { width: '12px', height: '12px', borderRadius: '50%' }
        }) : null,
        Handle ? React.createElement(Handle, { 
          key: 'target', 
          type: 'target', 
          position: targetPosition, 
          id: 'target',
          className: 'w-3 h-3 bg-blue-500',
          style: { width: '12px', height: '12px', borderRadius: '50%' }
        }) : null,
        React.createElement('div', { key: 'icon', className: 'flex items-center space-x-2 mb-2' }, [
          React.createElement('div', { key: 'icon-bg', className: 'w-8 h-8 bg-red-100 rounded flex items-center justify-center' }, [
            React.createElement('svg', { key: 'icon-svg', className: 'w-5 h-5 text-red-600', fill: 'none', stroke: 'currentColor', viewBox: '0 0 24 24' }, [
              React.createElement('path', { key: 'path', strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M13 10V3L4 14h7v7l9-11h-7z' })
            ])
          ])
        ]),
        React.createElement('div', { key: 'label', className: 'font-bold text-gray-900 text-sm' }, data.label || 'Untitled'),
        React.createElement('div', { key: 'service', className: 'text-xs text-gray-500 mt-1' }, data.service_name || ''),
        React.createElement('div', { key: 'hint', className: 'text-xs text-gray-400 mt-2 italic' }, 'Click to view data')
      ]);
    };

    // Main workflow builder component
    const WorkflowBuilder = () => {
      const [nodes, setNodes] = useState(workflowData.nodes || []);
      const [edges, setEdges] = useState(workflowData.edges || []);
      const reactFlowWrapper = useRef(null);
      const reactFlowInstance = useReactFlow();
      
      // Expose setNodes to window for manual drop handler - use useCallback to ensure stable reference
      const setNodesWrapper = useCallback((updater) => {
        setNodes(updater);
      }, []);
      
      // Expose functions to window only once on mount
      useEffect(() => {
        window.workflowSetNodes = setNodesWrapper;
        window.workflowServices = services;
        window.workflowReactFlowInstance = reactFlowInstance;
        return () => {
          delete window.workflowSetNodes;
          delete window.workflowServices;
          delete window.workflowReactFlowInstance;
        };
      }, [setNodesWrapper, services, reactFlowInstance]);
      
      // Update current nodes/edges without causing re-renders
      useEffect(() => {
        window.workflowNodes = nodes;
        window.workflowEdges = edges;
      }, [nodes, edges]);
      
      // Helper to get screen to flow position
      const getScreenToFlowPosition = (x, y) => {
        if (reactFlowInstance && reactFlowInstance.screenToFlowPosition) {
          return reactFlowInstance.screenToFlowPosition({ x, y });
        }
        // Fallback: approximate position
        const bounds = reactFlowWrapper.current?.getBoundingClientRect();
        if (bounds) {
          return {
            x: x - bounds.left - 100,
            y: y - bounds.top - 100
          };
        }
        return { x: 100, y: 100 };
      };

      const onNodesChange = useCallback((changes) => {
        setNodes((nds) => {
          const updated = nds.map((node) => {
            const change = changes.find((c) => c.id === node.id);
            if (change && change.type === 'position') {
              return { ...node, position: change.position };
            }
            return node;
          });
          // Only save if there are actual changes
          if (changes.length > 0) {
            saveWorkflow(updated, edges);
          }
          return updated;
        });
      }, [edges]);

      const onEdgesChange = useCallback((changes) => {
        setEdges((es) => {
          const updated = es.map((edge) => {
            const change = changes.find((c) => c.id === edge.id);
            return change ? { ...edge, ...change } : edge;
          });
          // Only save if there are actual changes
          if (changes.length > 0) {
            saveWorkflow(nodes, updated);
          }
          return updated;
        });
      }, [nodes]);

      const onConnect = useCallback((params) => {
        setEdges((eds) => {
          const newEdges = [...eds, params];
          saveWorkflow(nodes, newEdges);
          return newEdges;
        });
      }, [nodes]);

      const onDragOver = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        if (event.dataTransfer) {
          event.dataTransfer.dropEffect = 'move';
        }
        return false;
      }, []);

      const onDrop = useCallback((event) => {
        event.preventDefault();
        event.stopPropagation();
        
        console.log('=== DROP EVENT IN REACT FLOW ===');
        console.log('Drop event received in React Flow');
        console.log('DataTransfer types:', event.dataTransfer?.types);
        console.log('Drop location:', event.clientX, event.clientY);
        console.log('Current nodes count:', nodes.length);
        
        // Try multiple data transfer formats
        let serviceKey = null;
        try {
          serviceKey = event.dataTransfer.getData('application/reactflow');
          if (!serviceKey) {
            serviceKey = event.dataTransfer.getData('text/plain');
          }
          if (!serviceKey && event.dataTransfer.types) {
            // Try all available types
            for (let i = 0; i < event.dataTransfer.types.length; i++) {
              const type = event.dataTransfer.types[i];
              try {
                const data = event.dataTransfer.getData(type);
                if (data && data.trim()) {
                  console.log(`Found data in type ${type}:`, data);
                  serviceKey = data;
                  break;
                }
              } catch (e) {
                // Some types can't be read, skip them
                continue;
              }
            }
          }
        } catch (e) {
          console.error('Error reading drag data:', e);
        }
        
        if (!serviceKey) {
          console.warn('No service key in drag data. Available types:', event.dataTransfer?.types);
          return;
        }
        
        console.log('Service key found:', serviceKey);
        console.log('Services object:', services);
        console.log('Service key in services?', serviceKey in services);

        // Get position relative to React Flow viewport
        let position;
        try {
          if (reactFlowInstance && reactFlowInstance.screenToFlowPosition) {
            position = reactFlowInstance.screenToFlowPosition({
              x: event.clientX,
              y: event.clientY
            });
            console.log('React Flow onDrop: Position from screenToFlowPosition:', position);
          } else {
            // Fallback: get position relative to the React Flow container
            const reactFlowEl = document.querySelector('.react-flow__viewport') || 
                               document.querySelector('.react-flow') ||
                               reactFlowWrapper.current;
            if (reactFlowEl) {
              const rect = reactFlowEl.getBoundingClientRect();
              // Account for zoom and pan
              const viewport = reactFlowInstance?.getViewport?.() || { x: 0, y: 0, zoom: 1 };
              const zoom = viewport.zoom || reactFlowInstance?.getZoom?.() || 1;
              position = {
                x: (event.clientX - rect.left - viewport.x) / zoom,
                y: (event.clientY - rect.top - viewport.y) / zoom
              };
              console.log('React Flow onDrop: Position from fallback:', position, 'viewport:', viewport, 'zoom:', zoom);
            } else {
              // Last resort: offset from existing nodes with better spacing
              const lastNode = nodes[nodes.length - 1];
              if (lastNode && lastNode.position) {
                // Space nodes horizontally with more spacing, alternate Y for visual separation
                position = {
                  x: lastNode.position.x + 300,
                  y: lastNode.position.y + (nodes.length % 2 === 0 ? 150 : 0)
                };
              } else {
                position = { x: 200, y: 200 };
              }
              console.log('React Flow onDrop: Position from last resort:', position);
            }
          }
        } catch (error) {
          console.error('Error calculating drop position:', error);
          // Fallback to offset from existing nodes with better spacing
          const lastNode = nodes[nodes.length - 1];
          if (lastNode && lastNode.position) {
            // Space nodes horizontally with more spacing, alternate Y for visual separation
            position = {
              x: lastNode.position.x + 300,
              y: lastNode.position.y + (nodes.length % 2 === 0 ? 150 : 0)
            };
          } else {
            position = { x: 200, y: 200 };
          }
        }
        
        console.log('Dropping node at position:', position, 'for service:', serviceKey);
        console.log('Available services:', Object.keys(services));

        // Try both string and symbol keys
        const serviceInfo = services[serviceKey] || services[serviceKey.toString()];
        console.log('Service info for', serviceKey, ':', serviceInfo);
        
        // Create label from service info or fallback
        let label = serviceKey;
        if (serviceInfo) {
          // Try both 'name' and :name (from Ruby hash)
          label = serviceInfo.name || serviceInfo['name'] || serviceKey;
        } else {
          // Fallback: format the key nicely
          label = serviceKey.toString().replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }
        
        // Ensure position is valid
        if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {
          console.error('Invalid position, using default');
          position = { x: 100, y: 100 };
        }
        
        const newNode = {
          id: `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          type: 'service',
          position: { x: Number(position.x), y: Number(position.y) }, // Ensure numbers
          data: {
            label: label,
            service_name: serviceKey,
            config: {}
          },
          // Ensure required React Flow properties
          draggable: true,
          selectable: true
        };

        console.log('Creating new node:', newNode);
        console.log('Current nodes before add:', nodes.map(n => ({ id: n.id, label: n.data?.label, position: n.position })));

        setNodes((nds) => {
          console.log('setNodes called with current nodes:', nds.length);
          
          // Check if node with same ID already exists
          const existingNode = nds.find(n => n.id === newNode.id);
          if (existingNode) {
            console.warn('Node already exists, skipping');
            return nds;
          }
          
          const updated = [...nds, newNode];
          console.log('Updated nodes count:', updated.length);
          console.log('New nodes list:', updated.map(n => ({ 
            id: n.id, 
            label: n.data?.label, 
            position: n.position,
            type: n.type
          })));
          
          // Inspect DOM and fit view after state update
          setTimeout(() => {
            // Fit view to show all nodes
            if (reactFlowInstance && reactFlowInstance.fitView) {
              setTimeout(() => {
                reactFlowInstance.fitView({ 
                  padding: 0.3, 
                  duration: 400,
                  minZoom: 0.5,
                  maxZoom: 1.5
                });
              }, 100);
            }
            
            saveWorkflow(updated, edges);
          }, 300);
          
          return updated;
        });
      }, [nodes, edges, services, reactFlowInstance]);

      // Debounce save to prevent infinite loops
      let saveTimeout = null;
      const saveWorkflow = (nds, eds) => {
        // Expose to window for manual drop handler
        window.saveWorkflow = saveWorkflow;
        // Clear existing timeout
        if (saveTimeout) {
          clearTimeout(saveTimeout);
        }
        
        // Debounce: wait 500ms before saving
        saveTimeout = setTimeout(() => {
          const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
          if (!csrfToken) {
            console.error('CSRF token not found');
            return;
          }
          
          fetch(updateUrl, {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRF-Token': csrfToken,
              'Accept': 'application/json'
            },
            body: JSON.stringify({
              workflow: {
                workflow_data: {
                  nodes: nds,
                  edges: eds
                }
              }
            })
          })
          .then(response => {
            if (!response.ok) {
              return response.text().then(text => {
                throw new Error(`HTTP ${response.status}: ${text}`);
              });
            }
            return response.json();
          })
          .then(data => {
            console.log('Workflow saved successfully');
          })
          .catch(err => {
            console.error('Failed to save workflow:', err);
            // Don't retry on error to prevent infinite loop
          });
        }, 500);
      };

      if (!ReactFlowComponent) {
        return React.createElement('div', { className: 'p-4 text-red-600' }, 
          'Error: React Flow component not loaded. Please refresh the page.'
        );
      }
      
      const children = [];
      if (Background) {
        children.push(React.createElement(Background, { key: 'bg', gap: 16, size: 1 }));
      }
      if (Controls) {
        children.push(React.createElement(Controls, { key: 'controls' }));
      }
      if (MiniMap) {
        children.push(React.createElement(MiniMap, { key: 'minimap', nodeColor: '#ef4444' }));
      }
      
      // Ensure nodes have required properties and valid positions
      const validNodes = (nodes || []).map((node, index) => {
        // Ensure position is valid
        let position = node.position || { x: 0, y: 0 };
        if (typeof position.x !== 'number' || isNaN(position.x)) {
          position.x = 100 + (index * 250);
        }
        if (typeof position.y !== 'number' || isNaN(position.y)) {
          position.y = 100 + (index * 100);
        }
        
        return {
          id: String(node.id), // Ensure ID is string
          type: node.type || 'service',
          position: { x: Number(position.x), y: Number(position.y) },
          data: node.data || {},
          draggable: node.draggable !== false,
          selectable: node.selectable !== false
        };
      });
      
      return React.createElement('div', { 
        ref: reactFlowWrapper,
        className: 'h-full w-full',
        style: { 
          position: 'relative',
          width: '100%',
          height: '100%',
          minHeight: '800px'
        }
      }, [
        React.createElement(ReactFlowComponent, {
          key: 'flow',
          nodes: validNodes,
          edges: edges || [],
          onNodesChange: onNodesChange,
          onEdgesChange: onEdgesChange,
          onConnect: onConnect,
          onDrop: onDrop,
          onDragOver: onDragOver,
          nodeTypes: { service: ServiceNode },
          fitView: false, // We'll handle fitView manually after nodes are added
          defaultEdgeOptions: {
            style: { strokeWidth: 2, stroke: '#ef4444' },
            type: 'smoothstep'
          },
          connectionLineStyle: { strokeWidth: 2, stroke: '#ef4444' },
          snapToGrid: true,
          snapGrid: [16, 16],
          deleteKeyCode: 'Delete',
          multiSelectionKeyCode: 'Shift',
          nodesDraggable: true,
          nodesConnectable: true,
          elementsSelectable: true,
          proOptions: { hideAttribution: true },
          nodeOrigin: [0, 0],
          // Ensure proper rendering
          onlyRenderVisibleElements: false,
          // Prevent viewport issues
          minZoom: 0.1,
          maxZoom: 2
        }, children)
      ]);
    };

    // Setup drag and drop for sidebar items
    function setupDragAndDrop() {
      document.querySelectorAll('.service-item').forEach(item => {
        // Remove existing listeners by cloning
        if (item.hasAttribute('data-drag-setup')) {
          return; // Already set up
        }
        item.setAttribute('data-drag-setup', 'true');
        
        item.addEventListener('dragstart', (e) => {
          const serviceKey = item.dataset.serviceKey;
          if (serviceKey) {
            // Set data in multiple formats for compatibility
            e.dataTransfer.setData('application/reactflow', serviceKey);
            e.dataTransfer.setData('text/plain', serviceKey);
            e.dataTransfer.effectAllowed = 'move';
            
            // Create a visible drag image that shows what's being dragged
            const dragImage = item.cloneNode(true);
            dragImage.style.position = 'absolute';
            dragImage.style.top = '-1000px';
            dragImage.style.width = item.offsetWidth + 'px';
            dragImage.style.opacity = '0.8';
            dragImage.style.transform = 'rotate(5deg)';
            dragImage.style.pointerEvents = 'none';
            document.body.appendChild(dragImage);
            e.dataTransfer.setDragImage(dragImage, item.offsetWidth / 2, item.offsetHeight / 2);
            setTimeout(() => {
              if (document.body.contains(dragImage)) {
                document.body.removeChild(dragImage);
              }
            }, 0);
            
            // Add visual feedback to original
            item.style.opacity = '0.4';
            item.style.transform = 'scale(0.95)';
            
            console.log('Drag started for service:', serviceKey);
          } else {
            console.warn('Service item missing data-service-key attribute', item);
            e.preventDefault(); // Cancel drag if no service key
          }
        });
        
        item.addEventListener('dragend', (e) => {
          // Restore visual state
          item.style.opacity = '1';
          item.style.transform = '';
          console.log('Drag ended, dropEffect:', e.dataTransfer?.dropEffect);
          
          // If drop was successful (not cancelled), the node should be on canvas
          if (e.dataTransfer?.dropEffect === 'move') {
            console.log('Drop was successful');
          } else {
            console.log('Drop was cancelled or failed');
          }
        });
        
        // Make sure it's draggable
        item.setAttribute('draggable', 'true');
      });
    }
    
    // Prevent default drag behavior on the document to allow drops
    // This must be on the capture phase to work properly
    document.addEventListener('dragover', (e) => {
      // Always allow drops on React Flow canvas area
      const reactFlowArea = document.getElementById('react-flow-container') ||
                           document.getElementById('react-flow-root') || 
                           e.target.closest('.react-flow') ||
                           e.target.closest('[id*="react-flow"]');
      if (reactFlowArea) {
        e.preventDefault();
        e.stopPropagation();
        if (e.dataTransfer) {
          e.dataTransfer.dropEffect = 'move';
        }
        return false;
      }
    }, true); // Use capture phase
    
    // Manual drop handler as fallback if React Flow's onDrop doesn't work
    function handleManualDrop(e) {
      const reactFlowArea = document.getElementById('react-flow-container') ||
                           document.getElementById('react-flow-root') || 
                           e.target.closest('.react-flow') ||
                           e.target.closest('.react-flow__viewport') ||
                           e.target.closest('[id*="react-flow"]');
      
      if (!reactFlowArea) {
        // Not on React Flow area
        if (!e.target.closest('.service-item')) {
          e.preventDefault();
          e.stopPropagation();
        }
        return;
      }
      
      // Get service key from drag data
      let serviceKey = null;
      try {
        serviceKey = e.dataTransfer.getData('application/reactflow');
        if (!serviceKey) {
          serviceKey = e.dataTransfer.getData('text/plain');
        }
      } catch (err) {
        console.error('Error reading drag data:', err);
      }
      
      if (!serviceKey) {
        return; // Not a service drag
      }
      
      console.log('Manual drop handler triggered for:', serviceKey);
      
      // Use the exposed setNodes function
      if (window.workflowSetNodes && window.workflowServices && window.workflowReactFlowInstance) {
        const setNodes = window.workflowSetNodes;
        const services = window.workflowServices;
        const reactFlowInstance = window.workflowReactFlowInstance;
        const currentNodes = window.workflowNodes || [];
        const currentEdges = window.workflowEdges || [];
        
        // Calculate position relative to React Flow viewport
        let position;
        try {
          if (reactFlowInstance && reactFlowInstance.screenToFlowPosition) {
            position = reactFlowInstance.screenToFlowPosition({
              x: e.clientX,
              y: e.clientY
            });
            console.log('Position from screenToFlowPosition:', position);
          } else {
            // Fallback: calculate relative to React Flow container
            const reactFlowEl = document.querySelector('.react-flow__viewport') || 
                               document.querySelector('.react-flow') ||
                               document.getElementById('react-flow-root');
            if (reactFlowEl) {
              const rect = reactFlowEl.getBoundingClientRect();
              // Get current viewport transform if available
              const viewport = reactFlowInstance?.getViewport?.() || { x: 0, y: 0, zoom: 1 };
              const zoom = viewport.zoom || reactFlowInstance?.getZoom?.() || 1;
              
              // Calculate position accounting for zoom and pan
              position = {
                x: (e.clientX - rect.left - viewport.x) / zoom,
                y: (e.clientY - rect.top - viewport.y) / zoom
              };
              console.log('Position from fallback calculation:', position, 'viewport:', viewport, 'zoom:', zoom);
            } else {
              // Last resort: use mouse position with offset
              const existingNodes = currentNodes || [];
              const lastNode = existingNodes[existingNodes.length - 1];
              if (lastNode && lastNode.position) {
                // Offset from last node
                position = {
                  x: lastNode.position.x + 250,
                  y: lastNode.position.y
                };
              } else {
                position = { x: 100, y: 100 };
              }
              console.log('Position from last resort (offset from last node):', position);
            }
          }
        } catch (error) {
          console.error('Error calculating position:', error);
          // Fallback to offset from existing nodes
          const existingNodes = currentNodes || [];
          const lastNode = existingNodes[existingNodes.length - 1];
          if (lastNode && lastNode.position) {
            position = {
              x: lastNode.position.x + 300,
              y: lastNode.position.y + (currentNodes.length % 2 === 0 ? 150 : 0)
            };
          } else {
            position = { x: 200, y: 200 };
          }
        }
        
        const serviceInfo = services[serviceKey] || services[serviceKey.toString()];
        const label = serviceInfo?.name || serviceInfo?.['name'] || 
                     serviceKey.toString().replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        
        // Ensure position is valid numbers
        if (!position || typeof position.x !== 'number' || typeof position.y !== 'number') {
          console.error('Invalid position in manual drop, using default');
          const lastNode = currentNodes[currentNodes.length - 1];
          if (lastNode && lastNode.position) {
            position = { 
              x: lastNode.position.x + 300, 
              y: lastNode.position.y + (currentNodes.length % 2 === 0 ? 150 : 0)
            };
          } else {
            position = { x: 200, y: 200 };
          }
        }
        
        const newNode = {
          id: `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          type: 'service',
          position: { x: Number(position.x), y: Number(position.y) },
          data: {
            label: label,
            service_name: serviceKey,
            config: {}
          },
          draggable: true,
          selectable: true
        };
        
        console.log('Manual drop creating node:', newNode);
        
        setNodes((nds) => {
          // Check for duplicates
          const existing = nds.find(n => n.id === newNode.id);
          if (existing) {
            console.warn('Node already exists, skipping');
            return nds;
          }
          
          const updated = [...nds, newNode];
          console.log('Manual drop: Added node. Total nodes:', updated.length);
          console.log('New node position:', newNode.position);
          console.log('All node positions:', updated.map(n => ({ id: n.id, pos: n.position })));
          
          // Force React Flow to update by using a small delay
          setTimeout(() => {
            // Inspect what React Flow actually rendered
            setTimeout(() => {
              const reactFlowNodes = document.querySelectorAll('.react-flow__node');
              console.log('=== DOM INSPECTION ===');
              console.log('React Flow nodes in DOM:', reactFlowNodes.length);
              reactFlowNodes.forEach((nodeEl, idx) => {
                const transform = window.getComputedStyle(nodeEl).transform;
                const left = window.getComputedStyle(nodeEl).left;
                const top = window.getComputedStyle(nodeEl).top;
                const nodeId = nodeEl.getAttribute('data-id') || nodeEl.querySelector('[data-node-id]')?.getAttribute('data-node-id');
                console.log(`Node ${idx + 1}:`, {
                  id: nodeId,
                  transform: transform,
                  left: left,
                  top: top,
                  position: nodeEl.style.position
                });
              });
              
              // Try to fit view to show all nodes with proper padding
              if (reactFlowInstance && reactFlowInstance.fitView) {
                setTimeout(() => {
                  reactFlowInstance.fitView({ 
                    padding: 0.3, 
                    duration: 400,
                    minZoom: 0.5,
                    maxZoom: 1.5
                  });
                }, 100);
              } else if (reactFlowInstance && reactFlowInstance.getNodesBounds) {
                // Alternative: calculate bounds and set viewport
                const bounds = reactFlowInstance.getNodesBounds(updated);
                if (bounds) {
                  const viewport = reactFlowInstance.getViewport();
                  const x = -bounds.x + (viewport.width || 800) / 2 - bounds.width / 2;
                  const y = -bounds.y + (viewport.height || 600) / 2 - bounds.height / 2;
                  reactFlowInstance.setViewport({ x, y, zoom: 1 }, { duration: 400 });
                }
              }
            }, 300);
            
            // Save workflow
            if (window.saveWorkflow) {
              window.saveWorkflow(updated, currentEdges);
            }
          }, 100);
          
          return updated;
        });
        
        e.preventDefault();
        e.stopPropagation();
      }
    }
    
    // Add manual drop handler
    document.addEventListener('drop', handleManualDrop, true); // Use capture phase
    
    // Setup on page load and after Turbo navigation
    function initDragAndDrop() {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupDragAndDrop);
      } else {
        setupDragAndDrop();
      }
    }
    
    initDragAndDrop();
    
    // Re-setup after Turbo navigation
    document.addEventListener('turbo:load', setupDragAndDrop);
    document.addEventListener('turbo:render', setupDragAndDrop);

    // Setup modal close handlers
    function setupModalHandlers() {
      const modal = document.getElementById('node-data-modal');
      const closeBtn = document.getElementById('close-node-modal-btn');
      
      if (closeBtn) {
        closeBtn.onclick = () => {
          if (modal) modal.classList.add('hidden');
        };
      }
      
      if (modal) {
        modal.onclick = (e) => {
          if (e.target === modal) {
            modal.classList.add('hidden');
          }
        };
      }
    }
    
    setupModalHandlers();
    
    // Re-setup after Turbo navigation
    document.addEventListener('turbo:load', setupModalHandlers);
    document.addEventListener('turbo:render', setupModalHandlers);

    // Render React Flow
    const rootEl = document.getElementById('react-flow-root');
    if (!rootEl) {
      console.error('React Flow root element not found');
      return;
    }
    
    if (!ReactFlowProvider) {
      rootEl.innerHTML = '<div class="p-4 text-red-600">Error: React Flow Provider not loaded. Please refresh the page.</div>';
      return;
    }
    
    try {
      const root = ReactDOM.createRoot(rootEl);
      root.render(
        React.createElement(ReactFlowProvider, null,
          React.createElement(WorkflowBuilder)
        )
      );
    } catch (error) {
      console.error('Error rendering React Flow:', error);
      rootEl.innerHTML = `<div class="p-4 text-red-600">Error rendering workflow builder: ${error.message}</div>`;
    }
  })();
</script>
