<div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8">
  <div class="mb-6 flex justify-between items-center">
    <div>
      <h1 class="text-3xl font-bold text-gray-900"><%= @workflow.name %></h1>
      <p class="mt-2 text-sm text-gray-600"><%= @workflow.description %></p>
    </div>
    <div class="flex space-x-3">
      <%= link_to "Back to Workflows", admin_workflows_path, class: "inline-flex items-center px-4 py-2 border border-gray-300 text-sm font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50" %>
      <%= link_to "View Results", results_admin_workflow_path(@workflow), class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-green-600 hover:bg-green-700" %>
      <%= button_to "Execute Workflow", execute_admin_workflow_path(@workflow), method: :post, class: "inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md text-white bg-red-600 hover:bg-red-700" %>
    </div>
  </div>

  <!-- Workflow Builder with Sidebar -->
  <div class="bg-white shadow rounded-lg mb-6 overflow-hidden">
    <div class="flex" style="height: 800px;">
      <!-- Services Sidebar -->
      <div class="w-64 bg-gray-50 border-r border-gray-200 overflow-y-auto flex-shrink-0">
        <div class="p-4 border-b border-gray-200">
          <h3 class="text-sm font-semibold text-gray-900 uppercase tracking-wide">Available Services</h3>
          <p class="mt-1 text-xs text-gray-500">Click + to add to canvas</p>
        </div>
        <div class="p-2 space-y-2" id="services-sidebar">
          <% @service_info.each do |service_key, service_data| %>
            <div
              class="service-item p-3 bg-white rounded-lg border border-gray-200 shadow-sm hover:shadow-md transition-shadow"
              data-service-key="<%= service_key %>"
              data-service-name="<%= service_data[:name] %>">
              <div class="flex items-center space-x-2">
                <div class="flex-shrink-0">
                  <div class="w-8 h-8 bg-red-100 rounded flex items-center justify-center">
                    <svg class="w-5 h-5 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
                    </svg>
                  </div>
                </div>
                <div class="flex-1 min-w-0">
                  <p class="text-sm font-medium text-gray-900 truncate"><%= service_data[:name] %></p>
                  <p class="text-xs text-gray-500 truncate"><%= service_data[:description] %></p>
                </div>
                <button
                  type="button"
                  class="add-node-btn flex-shrink-0 w-8 h-8 bg-red-500 hover:bg-red-600 text-white rounded-full flex items-center justify-center transition-colors"
                  data-service-key="<%= service_key %>"
                  data-service-name="<%= service_data[:name] %>"
                  title="Add to canvas">
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4" />
                  </svg>
                </button>
              </div>
            </div>
          <% end %>
        </div>
      </div>

      <!-- React Flow Canvas -->
      <div class="flex-1 relative" id="react-flow-container" style="min-width: 0; width: 100%; height: 100%; overflow: hidden;">
        <div id="workflow-builder"
             data-workflow-id="<%= @workflow.id %>"
             data-workflow-data="<%= @workflow_data.to_json %>"
             data-services="<%= @service_info.to_json %>"
             data-update-url="<%= admin_workflow_path(@workflow) %>"
             data-node-data-url="<%= node_data_admin_workflow_path(@workflow) %>"
             data-update-node-config-url="<%= update_node_config_admin_workflow_path(@workflow) %>"
             style="width: 100%; height: 100%; position: relative;">
          <div id="react-flow-root" style="width: 100%; height: 100%; background: #f9fafb; position: relative;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Recent Executions -->
  <div class="bg-white shadow rounded-lg">
    <div class="px-4 py-5 sm:px-6">
      <h3 class="text-lg leading-6 font-medium text-gray-900">Recent Executions</h3>
    </div>
    <div class="border-t border-gray-200">
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Started</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Duration</th>
            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Records</th>
            <th scope="col" class="relative px-6 py-3"><span class="sr-only">View</span></th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
          <% @executions.each do |execution| %>
            <tr class="hover:bg-gray-50">
              <td class="px-6 py-4 whitespace-nowrap">
                <% case execution.status %>
                <% when 'completed' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">Completed</span>
                <% when 'failed' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-red-100 text-red-800">Failed</span>
                <% when 'running' %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-blue-100 text-blue-800">Running</span>
                <% else %>
                  <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-gray-100 text-gray-800">Pending</span>
                <% end %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.started_at ? time_ago_in_words(execution.started_at) + " ago" : "N/A" %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.duration ? "#{execution.duration.round(2)}s" : "N/A" %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                <%= execution.records_processed || 0 %>
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                <%= link_to "View", results_admin_workflow_path(@workflow, execution_id: execution.id), class: "text-red-600 hover:text-red-900" %>
              </td>
            </tr>
          <% end %>
        </tbody>
      </table>
    </div>
  </div>
</div>

<!-- Node Data Modal -->
<div id="node-data-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
  <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-4xl shadow-lg rounded-md bg-white">
    <div class="mt-3">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-medium text-gray-900" id="node-data-title">Node Data Output</h3>
        <button id="close-node-modal-btn" type="button" class="text-gray-400 hover:text-gray-600">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      <div id="node-data-content" class="max-h-96 overflow-y-auto">
        <div class="text-center py-8 text-gray-500">
          <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div>
          <p class="mt-2">Loading data...</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Node Configuration Modal -->
<div id="node-config-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
  <div class="relative top-10 mx-auto p-5 border w-11/12 max-w-xl shadow-lg rounded-md bg-white">
    <div class="mt-3">
      <div class="flex justify-between items-center mb-4">
        <h3 class="text-lg font-medium text-gray-900" id="node-config-title">Configure Node</h3>
        <button id="close-config-modal-btn" type="button" class="text-gray-400 hover:text-gray-600">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      <form id="node-config-form" class="space-y-4">
        <input type="hidden" id="config-node-id" name="node_id" />
        <input type="hidden" id="config-service-name" name="service_name" />

        <!-- Node Label -->
        <div>
          <label for="config-node-label" class="block text-sm font-medium text-gray-700">Node Label</label>
          <input type="text" id="config-node-label" name="label"
                 class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm"
                 placeholder="Enter a custom label for this node" />
        </div>

        <!-- Method Selection -->
        <div>
          <label for="config-method" class="block text-sm font-medium text-gray-700">Method</label>
          <select id="config-method" name="method"
                  class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm">
            <option value="">Select a method...</option>
          </select>
          <p id="method-description" class="mt-1 text-xs text-gray-500"></p>
        </div>

        <!-- Dynamic Input Fields Container -->
        <div id="config-inputs-container" class="space-y-4">
          <!-- Dynamic fields will be inserted here -->
        </div>

        <!-- API Key Section (for services that need it) -->
        <div id="api-key-section" class="hidden border-t pt-4 mt-4">
          <h4 class="text-sm font-medium text-gray-700 mb-2">API Configuration</h4>
          <div id="api-key-fields" class="space-y-3">
            <!-- API key fields will be inserted here -->
          </div>
        </div>

        <!-- Form Actions -->
        <div class="flex justify-end space-x-3 pt-4 border-t">
          <button type="button" id="cancel-config-btn"
                  class="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50">
            Cancel
          </button>
          <button type="submit"
                  class="px-4 py-2 text-sm font-medium text-white bg-red-600 border border-transparent rounded-md hover:bg-red-700">
            Save Configuration
          </button>
        </div>
      </form>
    </div>
  </div>
</div>

<%= javascript_include_tag "https://unpkg.com/react@18/umd/react.development.js" %>
<%= javascript_include_tag "https://unpkg.com/react-dom@18/umd/react-dom.development.js" %>
<%= javascript_include_tag "https://unpkg.com/reactflow@11/dist/umd/index.js" %>

<script>
  (function() {
    const builderEl = document.getElementById('workflow-builder');
    if (!builderEl) return;

    const workflowData = JSON.parse(builderEl.dataset.workflowData || '{"nodes":[],"edges":[]}');
    const services = JSON.parse(builderEl.dataset.services || '{}');
    const updateUrl = builderEl.dataset.updateUrl;
    const nodeDataUrlTemplate = builderEl.dataset.nodeDataUrl;
    const updateNodeConfigUrl = builderEl.dataset.updateNodeConfigUrl;
    const workflowId = builderEl.dataset.workflowId;

    const { React, ReactDOM } = window;
    const ReactFlow = window.ReactFlow;

    if (!React || !ReactDOM || !ReactFlow) {
      console.error('React Flow not loaded');
      return;
    }

    const { useCallback, useState, useRef, useEffect } = React;
    
    // React Flow v11 / @xyflow/react UMD build structure
    // Check what's available
    console.log('ReactFlow/XYFlow object:', window.ReactFlow || window.XYFlow || ReactFlow);
    const FlowLib = window.ReactFlow || window.XYFlow || ReactFlow;
    console.log('FlowLib keys:', Object.keys(FlowLib || {}));
    
    // Try different possible structures
    const ReactFlowProvider = FlowLib?.ReactFlowProvider || FlowLib?.default?.ReactFlowProvider;
    const useReactFlow = FlowLib?.useReactFlow || FlowLib?.default?.useReactFlow;
    const useNodesState = FlowLib?.useNodesState || FlowLib?.default?.useNodesState;
    const useEdgesState = FlowLib?.useEdgesState || FlowLib?.default?.useEdgesState;
    const addEdge = FlowLib?.addEdge || FlowLib?.default?.addEdge;
    const Background = FlowLib?.Background || FlowLib?.default?.Background;
    const Controls = FlowLib?.Controls || FlowLib?.default?.Controls;
    const MiniMap = FlowLib?.MiniMap || FlowLib?.default?.MiniMap;
    const Handle = FlowLib?.Handle || FlowLib?.default?.Handle;
    const Position = FlowLib?.Position || FlowLib?.default?.Position || {
      Left: 'left',
      Right: 'right',
      Top: 'top',
      Bottom: 'bottom'
    };
    const ReactFlowComponent = FlowLib?.ReactFlow || FlowLib?.default?.ReactFlow || FlowLib?.default;

    console.log('React Flow hooks available:', {
      useNodesState: !!useNodesState,
      useEdgesState: !!useEdgesState,
      addEdge: !!addEdge
    });
    
    // Validate components
    if (!ReactFlowProvider || !useReactFlow || !Background || !Controls || !Handle || !ReactFlowComponent) {
      console.error('Missing React Flow components:', {
        ReactFlowProvider: !!ReactFlowProvider,
        useReactFlow: !!useReactFlow,
        Background: !!Background,
        Controls: !!Controls,
        Handle: !!Handle,
        ReactFlowComponent: !!ReactFlowComponent
      });
      console.error('Available ReactFlow keys:', Object.keys(ReactFlow || {}));
    } else {
      console.log('All React Flow components loaded successfully');
    }

    // Enhanced Service Node with click handler and config button
    const ServiceNode = ({ data, id }) => {
      // Handle clicking the node body to view data
      const handleViewData = (e) => {
        e.stopPropagation();
        const modal = document.getElementById('node-data-modal');
        const title = document.getElementById('node-data-title');
        const content = document.getElementById('node-data-content');

        if (!modal || !title || !content) {
          console.error('Modal elements not found');
          return;
        }

        title.textContent = `${data.label || 'Node'} - Data Output`;
        content.innerHTML = '<div class="text-center py-8 text-gray-500"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-red-600 mx-auto"></div><p class="mt-2">Loading data...</p></div>';
        modal.classList.remove('hidden');

        // Fetch node data
        const url = `${nodeDataUrlTemplate}?node_id=${encodeURIComponent(id)}`;
        fetch(url, {
          headers: {
            'Accept': 'application/json',
            'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]')?.content || ''
          }
        })
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          return response.json();
        })
        .then(responseData => {
          if (responseData.error) {
            content.innerHTML = `<div class="text-center py-8 text-red-600">${responseData.error}</div>`;
            return;
          }

          let html = '';
          if (responseData.data && Array.isArray(responseData.data) && responseData.data.length > 0) {
            html = '<div class="overflow-x-auto"><table class="min-w-full divide-y divide-gray-200"><thead class="bg-gray-50"><tr>';
            const firstItem = responseData.data[0];
            const keys = Object.keys(firstItem);
            keys.forEach(key => {
              html += `<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${key}</th>`;
            });
            html += '</tr></thead><tbody class="bg-white divide-y divide-gray-200">';

            responseData.data.slice(0, 100).forEach((item) => {
              html += '<tr class="hover:bg-gray-50">';
              keys.forEach(key => {
                let value = item[key];
                if (value === undefined || value === null) {
                  value = '';
                } else if (typeof value === 'object') {
                  value = JSON.stringify(value);
                } else {
                  value = String(value);
                }
                // Escape HTML
                value = value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                html += `<td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">${value}</td>`;
              });
              html += '</tr>';
            });
            html += '</tbody></table></div>';
            if (responseData.data.length > 100) {
              html += `<div class="mt-4 text-sm text-gray-500 text-center">Showing first 100 of ${responseData.data.length} records</div>`;
            }
          } else {
            html = `<div class="text-center py-8 text-gray-500">${responseData.message || 'No data available. Execute the workflow to see results.'}</div>`;
          }
          content.innerHTML = html;
        })
        .catch(error => {
          console.error('Error loading node data:', error);
          content.innerHTML = `<div class="text-center py-8 text-red-600">Error loading data: ${error.message}</div>`;
        });
      };

      // Handle clicking the config/gear button
      const handleOpenConfig = (e) => {
        e.stopPropagation();
        e.preventDefault();
        console.log('Config button clicked for node:', id, data);
        if (window.openNodeConfigModal) {
          window.openNodeConfigModal(id, data);
        } else {
          console.error('openNodeConfigModal not defined yet');
          alert('Config modal not ready. Please try again.');
        }
      };

      const handlePosition = Position?.Right || 'right';
      const targetPosition = Position?.Left || 'left';

      // Get configured method name to display
      const configuredMethod = data.config?.method;
      const methodDisplay = configuredMethod ? `Method: ${configuredMethod}` : 'Click gear to configure';

      return React.createElement('div', {
        className: 'px-4 py-3 shadow-lg rounded-lg bg-white border-2 border-red-500 hover:border-red-600 transition-all',
        style: {
          width: 240,
          minHeight: 100,
          position: 'relative',
          zIndex: 1,
          boxSizing: 'border-box',
          backgroundColor: 'white'
        },
        'data-node-id': id
      }, [
        Handle ? React.createElement(Handle, {
          key: 'source',
          type: 'source',
          position: handlePosition,
          id: 'source',
          className: 'w-3 h-3 bg-red-500',
          style: { width: '12px', height: '12px', borderRadius: '50%' }
        }) : null,
        Handle ? React.createElement(Handle, {
          key: 'target',
          type: 'target',
          position: targetPosition,
          id: 'target',
          className: 'w-3 h-3 bg-blue-500',
          style: { width: '12px', height: '12px', borderRadius: '50%' }
        }) : null,
        // Header with icon and config button
        React.createElement('div', { key: 'header', className: 'flex items-center justify-between mb-2' }, [
          React.createElement('div', { key: 'icon-wrapper', className: 'flex items-center space-x-2' }, [
            React.createElement('div', { key: 'icon-bg', className: 'w-8 h-8 bg-red-100 rounded flex items-center justify-center' }, [
              React.createElement('svg', { key: 'icon-svg', className: 'w-5 h-5 text-red-600', fill: 'none', stroke: 'currentColor', viewBox: '0 0 24 24' }, [
                React.createElement('path', { key: 'path', strokeLinecap: 'round', strokeLinejoin: 'round', strokeWidth: '2', d: 'M13 10V3L4 14h7v7l9-11h-7z' })
              ])
            ])
          ]),
          // Config/Gear button
          React.createElement('button', {
            key: 'config-btn',
            onClick: handleOpenConfig,
            className: 'p-1.5 rounded-full hover:bg-gray-100 transition-colors',
            title: 'Configure node',
            style: { cursor: 'pointer' }
          }, [
            React.createElement('svg', {
              key: 'gear-icon',
              className: 'w-5 h-5 text-gray-500 hover:text-gray-700',
              fill: 'none',
              stroke: 'currentColor',
              viewBox: '0 0 24 24'
            }, [
              React.createElement('path', {
                key: 'gear-path',
                strokeLinecap: 'round',
                strokeLinejoin: 'round',
                strokeWidth: '2',
                d: 'M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z'
              }),
              React.createElement('path', {
                key: 'gear-center',
                strokeLinecap: 'round',
                strokeLinejoin: 'round',
                strokeWidth: '2',
                d: 'M15 12a3 3 0 11-6 0 3 3 0 016 0z'
              })
            ])
          ])
        ]),
        // Node label
        React.createElement('div', { key: 'label', className: 'font-bold text-gray-900 text-sm' }, data.label || 'Untitled'),
        // Service name
        React.createElement('div', { key: 'service', className: 'text-xs text-gray-500 mt-1' }, data.service_name || ''),
        // Method indicator
        React.createElement('div', {
          key: 'method',
          className: `text-xs mt-1 ${configuredMethod ? 'text-green-600' : 'text-gray-400 italic'}`
        }, methodDisplay),
        // View data button
        React.createElement('button', {
          key: 'view-data-btn',
          onClick: handleViewData,
          className: 'mt-2 w-full text-xs text-center py-1 px-2 bg-gray-50 hover:bg-gray-100 rounded border border-gray-200 text-gray-600 transition-colors',
          style: { cursor: 'pointer' }
        }, 'View Output Data')
      ]);
    };

    // Define nodeTypes outside component to prevent re-creation on each render
    const nodeTypes = { service: ServiceNode };

    // Main workflow builder component
    const WorkflowBuilder = () => {
      // Use React Flow's hooks if available for proper state management
      let nodes, setNodes, onNodesChangeFn;
      let edges, setEdges, onEdgesChangeFn;

      if (useNodesState && useEdgesState) {
        [nodes, setNodes, onNodesChangeFn] = useNodesState(workflowData.nodes || []);
        [edges, setEdges, onEdgesChangeFn] = useEdgesState(workflowData.edges || []);
        console.log('Using React Flow state hooks');
      } else {
        [nodes, setNodes] = useState(workflowData.nodes || []);
        [edges, setEdges] = useState(workflowData.edges || []);
        onNodesChangeFn = null;
        onEdgesChangeFn = null;
        console.log('Using regular useState (React Flow hooks not available)');
      }

      const reactFlowWrapper = useRef(null);
      const reactFlowInstance = useReactFlow();

      console.log('WorkflowBuilder render - nodes count:', nodes?.length);

      // Function to add a new node - exposed globally
      const addNewNode = useCallback((serviceKey, serviceName) => {
        console.log('addNewNode called with:', serviceKey, serviceName);

        // Calculate position based on existing nodes
        let position;
        if (nodes.length === 0) {
          position = { x: 100, y: 100 };
        } else {
          const maxX = Math.max(...nodes.map(n => n.position?.x || 0));
          const avgY = nodes.reduce((sum, n) => sum + (n.position?.y || 0), 0) / nodes.length;
          position = { x: maxX + 300, y: Math.max(100, avgY) };
        }

        const serviceInfo = services[serviceKey];
        const label = serviceInfo?.name || serviceName || serviceKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());

        const newNode = {
          id: `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          type: 'service',
          position: position,
          data: {
            label: label,
            service_name: serviceKey,
            config: {}
          },
          draggable: true,
          selectable: true
        };

        console.log('Creating node:', newNode);
        console.log('Current nodes before setNodes:', nodes);

        setNodes(currentNodes => {
          console.log('Inside setNodes callback, currentNodes:', currentNodes);
          const updated = [...currentNodes, newNode];
          console.log('State updated, nodes count:', updated.length, updated);

          // Save workflow after state update
          setTimeout(() => {
            saveWorkflowData(updated, edges);
          }, 100);

          return updated;
        });

        // Fit view after a short delay to show all nodes
        setTimeout(() => {
          if (reactFlowInstance?.fitView) {
            reactFlowInstance.fitView({ padding: 0.5, minZoom: 0.3, maxZoom: 1, duration: 300 });
          }
        }, 200);

      }, [nodes, edges, reactFlowInstance]);

      // Expose addNewNode globally
      useEffect(() => {
        window.addWorkflowNode = addNewNode;
        window.workflowNodes = nodes;
        window.workflowEdges = edges;
        console.log('Exposed addWorkflowNode to window, current nodes:', nodes.length);

        return () => {
          delete window.addWorkflowNode;
          delete window.workflowNodes;
          delete window.workflowEdges;
        };
      }, [addNewNode, nodes, edges]);

      // Save workflow data function
      const saveWorkflowData = useCallback((nds, eds) => {
        const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
        if (!csrfToken) {
          console.error('CSRF token not found');
          return;
        }

        fetch(updateUrl, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken,
            'Accept': 'application/json'
          },
          body: JSON.stringify({
            workflow: {
              workflow_data: {
                nodes: nds,
                edges: eds
              }
            }
          })
        })
        .then(response => response.json())
        .then(data => console.log('Workflow saved'))
        .catch(err => console.error('Save failed:', err));
      }, []);

      // Use React Flow's built-in change handlers (they handle all change types properly)
      const onNodesChange = useCallback((changes) => {
        if (onNodesChangeFn) {
          // Use React Flow's handler which properly handles all change types
          onNodesChangeFn(changes);
        }
      }, [onNodesChangeFn]);

      const onEdgesChange = useCallback((changes) => {
        if (onEdgesChangeFn) {
          onEdgesChangeFn(changes);
        }
      }, [onEdgesChangeFn]);

      const onConnect = useCallback((params) => {
        if (addEdge) {
          setEdges((eds) => addEdge(params, eds));
        } else {
          setEdges((eds) => [...eds, params]);
        }
        // Save after connecting
        setTimeout(() => saveWorkflowData(nodes, edges), 100);
      }, [nodes, edges, saveWorkflowData]);

      // Save on node drag end
      const onNodeDragStop = useCallback((event, node) => {
        console.log('Node drag stopped, saving...');
        saveWorkflowData(nodes, edges);
      }, [nodes, edges, saveWorkflowData]);

      if (!ReactFlowComponent) {
        return React.createElement('div', { className: 'p-4 text-red-600' }, 
          'Error: React Flow component not loaded. Please refresh the page.'
        );
      }
      
      const children = [];
      if (Background) {
        children.push(React.createElement(Background, { key: 'bg', gap: 16, size: 1 }));
      }
      if (Controls) {
        children.push(React.createElement(Controls, { key: 'controls' }));
      }
      if (MiniMap) {
        children.push(React.createElement(MiniMap, { key: 'minimap', nodeColor: '#ef4444' }));
      }
      
      // Ensure nodes have required properties and valid positions
      console.log('Rendering with nodes:', nodes?.length, nodes);
      let validNodes = (nodes || []).map((node, index) => {
        // Ensure position is valid
        let position = node.position || { x: 0, y: 0 };
        if (typeof position.x !== 'number' || isNaN(position.x)) {
          position.x = 200 + (index * 300);
        }
        if (typeof position.y !== 'number' || isNaN(position.y)) {
          position.y = 200 + (index % 2 === 0 ? 0 : 150);
        }
        
        return {
          id: String(node.id), // Ensure ID is string
          type: node.type || 'service',
          position: { x: Number(position.x), y: Number(position.y) },
          data: node.data || {},
          draggable: node.draggable !== false,
          selectable: node.selectable !== false
        };
      });
      
      // Ensure unique positions - if two nodes have same position, offset them
      const positionMap = new Map();
      validNodes = validNodes.map((node, index) => {
        const posKey = `${node.position.x},${node.position.y}`;
        if (positionMap.has(posKey)) {
          // Offset this node to avoid overlap
          const offset = positionMap.get(posKey);
          node.position.x += 300;
          node.position.y += (offset % 2 === 0 ? 0 : 150);
          positionMap.set(posKey, offset + 1);
        } else {
          positionMap.set(posKey, 1);
        }
        return node;
      });
      
      return React.createElement('div', { 
        ref: reactFlowWrapper,
        style: { 
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          width: '100%',
          height: '100%'
        }
      }, [
        React.createElement(ReactFlowComponent, {
          key: 'flow',
          nodes: validNodes,
          edges: edges || [],
          onNodesChange: onNodesChange,
          onEdgesChange: onEdgesChange,
          onConnect: onConnect,
          onNodeDragStop: onNodeDragStop,
          nodeTypes: nodeTypes,
          fitView: true,
          fitViewOptions: { padding: 0.8, minZoom: 0.2, maxZoom: 1 },
          defaultEdgeOptions: {
            style: { strokeWidth: 2, stroke: '#ef4444' },
            type: 'smoothstep'
          },
          connectionLineStyle: { strokeWidth: 2, stroke: '#ef4444' },
          snapToGrid: true,
          snapGrid: [16, 16],
          deleteKeyCode: 'Delete',
          multiSelectionKeyCode: 'Shift',
          nodesDraggable: true,
          nodesConnectable: true,
          elementsSelectable: true,
          proOptions: { hideAttribution: true },
          minZoom: 0.05,
          maxZoom: 2,
          defaultViewport: { x: 100, y: 100, zoom: 0.5 }
        }, children)
      ]);
    };

    // Setup modal close handlers
    function setupModalHandlers() {
      const modal = document.getElementById('node-data-modal');
      const closeBtn = document.getElementById('close-node-modal-btn');

      if (closeBtn) {
        closeBtn.onclick = () => {
          if (modal) modal.classList.add('hidden');
        };
      }

      if (modal) {
        modal.onclick = (e) => {
          if (e.target === modal) {
            modal.classList.add('hidden');
          }
        };
      }

      // Config modal handlers
      const configModal = document.getElementById('node-config-modal');
      const closeConfigBtn = document.getElementById('close-config-modal-btn');
      const cancelConfigBtn = document.getElementById('cancel-config-btn');

      if (closeConfigBtn) {
        closeConfigBtn.onclick = () => {
          if (configModal) configModal.classList.add('hidden');
        };
      }

      if (cancelConfigBtn) {
        cancelConfigBtn.onclick = () => {
          if (configModal) configModal.classList.add('hidden');
        };
      }

      if (configModal) {
        configModal.onclick = (e) => {
          if (e.target === configModal) {
            configModal.classList.add('hidden');
          }
        };
      }
    }

    setupModalHandlers();

    // Re-setup after Turbo navigation
    document.addEventListener('turbo:load', setupModalHandlers);
    document.addEventListener('turbo:render', setupModalHandlers);

    // Node configuration modal functions
    let currentConfigNodeId = null;
    let currentConfigNodeData = null;

    // Open the node configuration modal
    window.openNodeConfigModal = function(nodeId, nodeData) {
      console.log('openNodeConfigModal called with:', nodeId, nodeData);
      currentConfigNodeId = nodeId;
      currentConfigNodeData = nodeData;

      const modal = document.getElementById('node-config-modal');
      const title = document.getElementById('node-config-title');
      const nodeIdField = document.getElementById('config-node-id');
      const serviceNameField = document.getElementById('config-service-name');
      const labelField = document.getElementById('config-node-label');
      const methodSelect = document.getElementById('config-method');
      const methodDescription = document.getElementById('method-description');
      const inputsContainer = document.getElementById('config-inputs-container');
      const apiKeySection = document.getElementById('api-key-section');
      const apiKeyFields = document.getElementById('api-key-fields');

      if (!modal) {
        console.error('Config modal element not found!');
        return;
      }
      console.log('Modal element found, proceeding...');

      // Set title and hidden fields
      title.textContent = `Configure: ${nodeData.label || nodeData.service_name || 'Node'}`;
      nodeIdField.value = nodeId;
      serviceNameField.value = nodeData.service_name || '';
      labelField.value = nodeData.label || '';

      // Get service info for this node
      const serviceName = nodeData.service_name;
      const serviceInfo = services[serviceName];

      // Clear and populate method dropdown
      methodSelect.innerHTML = '<option value="">Select a method...</option>';
      methodDescription.textContent = '';
      inputsContainer.innerHTML = '';

      if (serviceInfo && serviceInfo.methods) {
        Object.entries(serviceInfo.methods).forEach(([methodKey, methodInfo]) => {
          const option = document.createElement('option');
          option.value = methodKey;
          option.textContent = methodInfo.name || methodKey;
          // Select current method if configured
          if (nodeData.config && nodeData.config.method === methodKey) {
            option.selected = true;
          }
          methodSelect.appendChild(option);
        });

        // If a method is selected, show its description and inputs
        if (nodeData.config && nodeData.config.method) {
          const selectedMethod = serviceInfo.methods[nodeData.config.method];
          if (selectedMethod) {
            methodDescription.textContent = selectedMethod.description || '';
            renderInputFields(selectedMethod.inputs || {}, nodeData.config || {});
          }
        }
      }

      // Handle method selection change
      methodSelect.onchange = function() {
        const selectedMethodKey = this.value;
        inputsContainer.innerHTML = '';
        methodDescription.textContent = '';

        if (selectedMethodKey && serviceInfo && serviceInfo.methods && serviceInfo.methods[selectedMethodKey]) {
          const methodInfo = serviceInfo.methods[selectedMethodKey];
          methodDescription.textContent = methodInfo.description || '';
          renderInputFields(methodInfo.inputs || {}, nodeData.config || {});
        }
      };

      // Handle API key section for services that need it
      apiKeySection.classList.add('hidden');
      apiKeyFields.innerHTML = '';

      if (serviceName === 'abuse_ch' || serviceName === 'abuseipdb') {
        apiKeySection.classList.remove('hidden');
        const apiKeyName = serviceName === 'abuse_ch' ? 'abuse_ch_api_key' : 'abuseipdb_api_key';
        const apiKeyLabel = serviceName === 'abuse_ch' ? 'abuse.ch API Key' : 'AbuseIPDB API Key';

        apiKeyFields.innerHTML = `
          <div>
            <label for="config-api-key" class="block text-sm font-medium text-gray-700">${apiKeyLabel}</label>
            <input type="password" id="config-api-key" name="api_key"
                   class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm"
                   placeholder="Enter API key (optional)"
                   value="${(nodeData.config && nodeData.config.api_key) || ''}" />
            <p class="mt-1 text-xs text-gray-500">API key will be stored securely with this node's configuration.</p>
          </div>
        `;
      }

      console.log('Showing config modal');
      modal.classList.remove('hidden');
    };

    // Render dynamic input fields based on method inputs
    function renderInputFields(inputs, currentConfig) {
      const container = document.getElementById('config-inputs-container');
      container.innerHTML = '';

      if (!inputs || Object.keys(inputs).length === 0) {
        container.innerHTML = '<p class="text-sm text-gray-500 italic">This method has no configurable inputs.</p>';
        return;
      }

      Object.entries(inputs).forEach(([inputKey, inputDef]) => {
        const fieldDiv = document.createElement('div');

        const label = document.createElement('label');
        label.htmlFor = `config-input-${inputKey}`;
        label.className = 'block text-sm font-medium text-gray-700';
        label.textContent = inputKey.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        if (inputDef.required) {
          label.innerHTML += ' <span class="text-red-500">*</span>';
        }
        fieldDiv.appendChild(label);

        let inputEl;
        const currentValue = currentConfig[inputKey] !== undefined ? currentConfig[inputKey] : (inputDef.default || '');

        if (inputDef.type === 'string' && inputKey === 'operator') {
          // Special case: operator dropdown
          inputEl = document.createElement('select');
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm';
          ['equals', 'contains', 'greater_than', 'less_than'].forEach(op => {
            const opt = document.createElement('option');
            opt.value = op;
            opt.textContent = op.replace(/_/g, ' ');
            if (currentValue === op) opt.selected = true;
            inputEl.appendChild(opt);
          });
        } else if (inputDef.type === 'object') {
          // For object types, use textarea with JSON
          inputEl = document.createElement('textarea');
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm font-mono text-xs';
          inputEl.rows = 4;
          inputEl.placeholder = 'Enter JSON object, e.g., {"old_field": "new_field"}';
          inputEl.value = typeof currentValue === 'object' ? JSON.stringify(currentValue, null, 2) : currentValue;
        } else if (inputDef.type === 'integer') {
          inputEl = document.createElement('input');
          inputEl.type = 'number';
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm';
          inputEl.value = currentValue;
        } else {
          inputEl = document.createElement('input');
          inputEl.type = 'text';
          inputEl.className = 'mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-red-500 focus:ring-red-500 sm:text-sm';
          inputEl.value = currentValue;
        }

        inputEl.id = `config-input-${inputKey}`;
        inputEl.name = inputKey;
        if (inputDef.required) inputEl.required = true;

        fieldDiv.appendChild(inputEl);

        // Add help text if default value exists
        if (inputDef.default !== undefined) {
          const helpText = document.createElement('p');
          helpText.className = 'mt-1 text-xs text-gray-500';
          helpText.textContent = `Default: ${inputDef.default}`;
          fieldDiv.appendChild(helpText);
        }

        container.appendChild(fieldDiv);
      });
    }

    // Handle form submission
    document.getElementById('node-config-form').addEventListener('submit', function(e) {
      e.preventDefault();

      if (!currentConfigNodeId) return;

      const formData = new FormData(this);
      const config = {};

      // Get method
      const method = formData.get('method');
      if (method) {
        config.method = method;
      }

      // Get all input fields from the inputs container
      const inputsContainer = document.getElementById('config-inputs-container');
      const inputs = inputsContainer.querySelectorAll('input, select, textarea');
      inputs.forEach(input => {
        if (input.name && input.value !== '') {
          // Try to parse JSON for object fields
          if (input.tagName === 'TEXTAREA') {
            try {
              config[input.name] = JSON.parse(input.value);
            } catch {
              config[input.name] = input.value;
            }
          } else if (input.type === 'number') {
            config[input.name] = parseInt(input.value, 10);
          } else {
            config[input.name] = input.value;
          }
        }
      });

      // Get API key if present
      const apiKeyInput = document.getElementById('config-api-key');
      if (apiKeyInput && apiKeyInput.value) {
        config.api_key = apiKeyInput.value;
      }

      // Get label
      const label = formData.get('label');

      // Save configuration
      const csrfToken = document.querySelector('meta[name="csrf-token"]')?.content;
      fetch(`${updateNodeConfigUrl}?node_id=${encodeURIComponent(currentConfigNodeId)}`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': csrfToken,
          'Accept': 'application/json'
        },
        body: JSON.stringify({
          config: config,
          label: label
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Update the node in React Flow state
          if (window.workflowSetNodes) {
            window.workflowSetNodes(nodes => nodes.map(node => {
              if (node.id === currentConfigNodeId) {
                return {
                  ...node,
                  data: {
                    ...node.data,
                    label: label || node.data.label,
                    config: config
                  }
                };
              }
              return node;
            }));
          }

          // Close modal
          document.getElementById('node-config-modal').classList.add('hidden');

          // Show success feedback
          console.log('Node configuration saved successfully');
        } else {
          alert('Error saving configuration: ' + (data.error || 'Unknown error'));
        }
      })
      .catch(error => {
        console.error('Error saving node configuration:', error);
        alert('Error saving configuration: ' + error.message);
      });
    });

    // Render React Flow
    const rootEl = document.getElementById('react-flow-root');
    if (!rootEl) {
      console.error('React Flow root element not found');
      return;
    }
    
    if (!ReactFlowProvider) {
      rootEl.innerHTML = '<div class="p-4 text-red-600">Error: React Flow Provider not loaded. Please refresh the page.</div>';
      return;
    }
    
    try {
      const root = ReactDOM.createRoot(rootEl);
      root.render(
        React.createElement(ReactFlowProvider, null,
          React.createElement(WorkflowBuilder)
        )
      );

      // Setup click-to-add handlers after React renders
      setTimeout(() => {
        setupAddNodeButtons();
      }, 500);

      function setupAddNodeButtons() {
        const addButtons = document.querySelectorAll('.add-node-btn');
        console.log('Setting up', addButtons.length, 'add node buttons');

        addButtons.forEach(btn => {
          // Remove existing listeners by cloning
          const newBtn = btn.cloneNode(true);
          btn.parentNode.replaceChild(newBtn, btn);

          newBtn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const serviceKey = newBtn.dataset.serviceKey;
            const serviceName = newBtn.dataset.serviceName;

            console.log('Add button clicked for:', serviceKey);

            if (!window.addWorkflowNode) {
              console.error('addWorkflowNode not available yet');
              alert('Please wait for the canvas to load');
              return;
            }

            // Call the exposed function
            window.addWorkflowNode(serviceKey, serviceName);

            // Visual feedback
            newBtn.classList.add('scale-90');
            setTimeout(() => newBtn.classList.remove('scale-90'), 150);
          });
        });

        console.log('Add node buttons setup complete');
      }

    } catch (error) {
      console.error('Error rendering React Flow:', error);
      rootEl.innerHTML = `<div class="p-4 text-red-600">Error rendering workflow builder: ${error.message}</div>`;
    }
  })();
</script>
